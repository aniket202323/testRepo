CREATE PROCEDURE [dbo].[spASP_wrVariableSPCChart]
@VariableId 	  	  	 int,
@StartTime 	  	  	 datetime,
@EndTime 	  	  	 datetime,
@NumberOfPoints 	  	 int,
@Direction 	  	  	 tinyint = 0, 	 -- 0 = Forward; 1 = Backwards
@ProductList 	  	 nVarChar(1000) = NULL,
@ShiftList 	  	  	 nVarChar(1000) = NULL,
@CrewList 	  	  	 nVarChar(1000) = NULL,
@OrderList 	  	  	 nVarChar(1000) = NULL,
@EventList  	  	  	 varchar(8000) = NULL,
@NPFilter 	  	  	 bit = 0,
@ChartType 	  	  	 smallint = 6,
@CLType 	  	  	  	 smallint = 0, 	 -- 0=Fixed; 1=Calculated
@SubgroupType 	  	 smallint = 0, 	 -- 0=Variable; 1=Time-Series
@SubgroupSize 	  	 int = 1,
@SigmaFactor 	  	 int = 3,
@GoodValue 	  	  	 nVarChar(100) = NULL,
@InTimeZone 	  	  	 nvarchar(200) = NULL 	 
AS
/*
Procedure: 	  	  	 spASP_wrVariableSPCChart
Author: 	  	  	  	 Matthew Wells (GE)
Date Created: 	  	 2009/03/05
Editor Tab Spacing: 	 4
Description:
============
Generates the subgrouped data set for the following set of SPC charts 
and optionally calculates the limits:
1) X/MR (I/MR)
2) XBar/R
3) XBar/S
4) U Chart
5) P Chart
The report also:
1) Links the data set to alarms generated by the AlarmMgr
2) Calculates a set of descriptive statistics
Parameters:
===========
@VariableId 	  	 - Selected variable to report on
@NumberOfPoints 	 - Number of data (NoD) points if NoD filter selected, data will be
 	  	  	  	   selected for based on NoD from the specified End Time
@StartTime 	  	 - Start time of report range if time range filter selected
@EndTime 	  	 - End time of report range if time range filter selected
 	  	  	  	   or reference point if NoD selected
@Direction 	  	 - Direction for NoD query from End Time
 	  	  	  	  	 0: Backwards (Default)
 	  	  	  	  	 1: Forwards
@ProductList 	 - Comma-delimited string list of product ids (i.e. '43,12,22')
@ShiftList 	  	 - Comma-delimited string list of shift names (i.e. 'Day,Night')
@CrewList 	  	 - Comma-delimited string list of shift crews (i.e. 'A,B,C')
@POList 	  	  	 - Comma-delimited string list of order ids (i.e. '43,12,22')
@EventList  	  	 - Comma-delimited string list of event ids (i.e. '43,12,22')
@NPFilter 	  	 - Apply Non-Productive time filter or not
 	  	  	  	  	 0: No (Default)
 	  	  	  	  	 1: Yes
@ChartType 	  	 - Type of variable chart to calculate
 	  	  	  	  	 0: None
 	  	  	  	  	 4: XBar/R
 	  	  	  	  	 5: Xbar/S
 	  	  	  	  	 6: X/MR (Default)
@CLType 	  	  	 - Fixed or calculated limits
 	  	  	  	  	 0: Fixed (Default)
 	  	  	  	  	 1: Calculated
@SubgroupType 	 - Type of subgroup - this is forced to 0 if the variable is an SPC Variable
 	  	  	  	  	 0=Variable (Default)
 	  	  	  	  	 1=Time-Series
@SubgroupSize 	 - Size of the subgroup for Time-Series SubgroupType only
@SigmaFactor 	 - Constant used in the calculation of the control limits
@GoodValue 	 - If supplied, Is used to calculate U/P Charts instead of spec limits, when time series group. 	  	  	 
Notes:
======
Change Date 	 Who 	  	 What
=========== 	 ==== 	 =====
2009-05-20 	 MKW 	  	 Added alarm description details and direction to number of points filter
2009-05-25 	 MKW 	  	 Changed sp so that if time-series subgroups are selected then the remainder data
 	  	  	  	  	 points are not included in analysis.
 	  	  	  	  	 Added Target to @Subgroups and @Statistics to fix bug of using average for target
2009-06-22 	 MKW 	  	 Fixed Process Sigma for Pp, Ppk and Z statistics and fixed missing PUId reference in Number of Points data query
2009-06-23 	 MKW 	  	 Fixed process statistics for SPC variables
2009-07-08 	 MKW 	  	 Added sort order for statistics by time
 	  	  	  	  	 Changed large tables from table variables to temp tables
2010-04-14 	 MK 	  	 Added/Edited code for 2 more chart types (P/U).
2018-08-22 	 Prasad 	  	 Included starttime in the slice, excluded endtime
*/
/***TESTING***
SELECT 	 @VariableId 	  	 = 30, --645, --63, --30
 	  	 @StartTime 	  	 = '2004-01-01',
 	  	 @EndTime 	  	 = '2009-07-01',
-- 	  	 @NumberOfPoints 	 = 5000,
-- 	  	 @ProductList 	 = '1,2,3',
-- 	  	 @CrewList 	  	 = 'A,B,C,D',
-- 	  	 @ShiftList 	  	 = 'Day,Night',
-- 	  	 @EventList 	  	 = '28812,28813,28814,28815,28816,28817,28818,28819,28820,28821,28822,28823,28824,28825,28826,28827,28828,28829,28830,28831,28832,28833,28834,28835,28836,28837,28838,28839,28840,28841,28842',
 	  	 @ChartType 	  	 = 6,
 	  	 @CLType 	  	  	 = 0,
 	  	 @SubgroupType 	 = 0,
 	  	 @SubgroupSize 	 = 1,
 	  	 @SigmaFactor 	 = 3
*/
/******************************************************************************
** 	  	  	  	  	  	  	  	 DECLARATIONS 	  	  	  	  	  	  	  	  **
******************************************************************************/
DECLARE 	 @PUId 	  	  	  	  	 int,
 	  	 @ETId 	  	  	  	  	 int,
 	  	 @DTId 	  	  	  	  	 int,
 	  	 @ProdId 	  	  	  	  	 int,
 	  	 @SPCVarTypeId 	  	  	 int,
 	  	 @SPCChildVarTypeId 	  	 int,
 	  	 @RVarId 	  	  	  	  	 int,
 	  	 @SVarId 	  	  	  	  	 int,
 	  	 @MRVarId 	  	  	  	 int,
 	  	 @PreVarId 	  	  	  	 int,
 	  	 @PreRVarId 	  	  	  	 int,
 	  	 @PreSVarId 	  	  	  	 int,
 	  	 @PreMRVarId 	  	  	  	 int,
 	  	 @SpecVarId 	  	  	  	 int,
 	  	 @SpecParmId 	  	  	  	 int,
 	  	 @SpecParm 	  	  	  	 nvarchar(25),
 	  	 @Count 	  	  	  	  	 int,
 	  	 @sSQL 	  	  	  	  	 varchar(8000),
 	  	 @sEndTime 	  	  	  	 varchar(32),
 	  	 @sStartTime 	  	  	  	 varchar(32),
 	  	 @sPUId 	  	  	  	  	 varchar(16),
 	  	 @sVariableId 	  	  	 varchar(16),
 	  	 @Row 	  	  	  	  	 int,
 	  	 @Rows 	  	  	  	  	 int,
 	  	 @SubgroupIndexFill 	  	 int,
 	  	 @SubgroupIndexFillId 	 int,
 	  	 @AlarmOrder 	  	  	  	 int,
 	  	  @GoodValueMin 	  	  	  	 float, --MK
 	  	  @GoodValueMax 	  	  	  	 float, --MK
 	  	  @sGoodValueMin 	  	  	  	 nvarchar(100), --MK
 	  	  @sGoodValueMax 	  	  	  	 nvarchar(100), --MK
 	  	  @DType_Id 	  	  	  	  	 int --MK
Declare @LangId INT
Declare @EngineeringUnits nvarchar(25)
Declare @BasisProduct int
EXEC spWA_GetCurrentUserInfo @LangId = @LangId OUTPUT
-- Data filter tables
DECLARE @Products 	 TABLE ( 	 ProdId 	  	 int PRIMARY KEY)
DECLARE @Crews 	  	 TABLE ( 	 CrewDesc 	 nvarchar(25) PRIMARY KEY)
DECLARE @Shifts 	  	 TABLE ( 	 ShiftDesc 	 nvarchar(25) PRIMARY KEY)
DECLARE @Orders 	  	 TABLE ( 	 PPId 	  	 int PRIMARY KEY)
DECLARE @Events 	  	 TABLE ( 	 EventId 	  	 int PRIMARY KEY)
-- Initial base data table
CREATE TABLE #Tests ( 	 XId 	  	  	 int IDENTITY(1,1) PRIMARY KEY NONCLUSTERED,
 	  	  	  	  	  	 SubgroupId 	 int DEFAULT 1,
 	  	  	  	  	  	 TestId 	  	 BigInt,
 	  	  	  	  	  	 Timestamp 	 datetime,
 	  	  	  	  	  	 Result 	  	 nvarchar(25), --MK float,
 	  	  	  	  	  	 ProdId 	  	 int,
 	  	  	  	  	  	 IsBasisProduct bit,
 	  	  	  	  	  	 EventId 	 int,
 	  	  	  	  	  	 Defect 	  	 float)  --MK
CREATE CLUSTERED INDEX CIdx_ProdSubgroup ON #Tests (ProdId, SubgroupId)
DECLARE @TestProducts TABLE ( 	 TPId 	 int PRIMARY KEY IDENTITY(1,1),
 	  	  	  	  	  	  	  	 ProdId 	 int)
CREATE TABLE #SubgroupIndex ( 	 SubgroupIndexId 	 int IDENTITY(1,1) PRIMARY KEY NONCLUSTERED,
 	  	  	  	  	  	  	  	 XId 	  	  	  	 int)
CREATE NONCLUSTERED INDEX idx_X ON #SubgroupIndex(XId)
CREATE TABLE #Subgroups ( 	 SubgroupId 	  	 int PRIMARY KEY NONCLUSTERED,
 	  	  	  	  	  	  	 TestId 	  	 BigInt,
 	  	  	  	  	  	  	 R_TestId 	  	 BigInt,
 	  	  	  	  	  	  	 S_TestId 	  	 BigInt,
 	  	  	  	  	  	  	 MR_TestId 	  	 BigInt,
 	  	  	  	  	  	  	 Timestamp 	  	 datetime,
 	  	  	  	  	  	  	 Result 	  	  	 nvarchar(25), --MK float,
 	  	  	  	  	  	  	 Size 	  	  	 int,
 	  	  	  	  	  	  	 ProdId 	  	  	 int,
 	  	  	  	  	  	  	 R 	  	  	  	 float,
 	  	  	  	  	  	  	 S 	  	  	  	 float,
 	  	  	  	  	  	  	 MR 	  	  	  	 float,
 	  	  	  	  	  	  	 UChart 	  	  	  float, --MK
 	  	  	  	  	  	     PChart 	  	  	  float, --MK
 	  	  	  	  	  	  	 XUSL 	  	  	 float,
 	  	  	  	  	  	  	 XUCL 	  	  	 float,
 	  	  	  	  	  	  	 XUWL 	  	  	 float,
 	  	  	  	  	  	  	 XUUL 	  	  	 float,
 	  	  	  	  	  	  	 XCL 	  	  	  	 float,
 	  	  	  	  	  	  	 XLUL 	  	  	 float,
 	  	  	  	  	  	  	 XLWL 	  	  	 float,
 	  	  	  	  	  	  	 XLCL 	  	  	 float,
 	  	  	  	  	  	  	 XLSL 	  	  	 float,
 	  	  	  	  	  	  	 Target 	  	  	 float,
 	  	  	  	  	  	  	 MRSUSL 	  	  	 float,
 	  	  	  	  	  	  	 MRSUCL 	  	  	 float,
 	  	  	  	  	  	  	 MRSUWL 	  	  	 float,
 	  	  	  	  	  	  	 MRSUUL 	  	  	 float,
 	  	  	  	  	  	  	 MRSCL 	  	  	 float,
 	  	  	  	  	  	  	 MRSLUL 	  	  	 float,
 	  	  	  	  	  	  	 MRSLWL 	  	  	 float,
 	  	  	  	  	  	  	 MRSLCL 	  	  	 float,
 	  	  	  	  	  	  	 MRSLSL 	  	  	 float,
 	  	  	  	  	  	  	 Alarm 	  	  	 smallint DEFAULT 0,
 	  	  	  	  	  	  	 EventId 	  	  	 int,
 	  	  	  	  	  	  	 DataPointText 	 nVarChar(1000) DEFAULT '')
CREATE CLUSTERED INDEX CIdx_ProdTimestamp ON #Subgroups (ProdId, TimeStamp)
DECLARE @Individuals TABLE (VarId 	 int PRIMARY KEY)
-- Statistics
DECLARE @Statistics TABLE ( 	 RunId 	  	  	  	 int PRIMARY KEY IDENTITY(1,1),
 	  	  	  	  	  	  	 ProdId 	  	  	  	 int,
 	  	  	  	  	  	  	 LSL 	  	  	  	  	 float,
 	  	  	  	  	  	  	 USL 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Target 	  	  	  	 float,
 	  	  	  	  	  	  	 Mean 	  	  	  	 float, 	 -- Average of the subgroups
 	  	  	  	  	  	  	 Minimum 	  	  	  	 float, 	 -- Minimum subgroup value
 	  	  	  	  	  	  	 Maximum 	  	  	  	 float, 	 -- Maximum subgroup value
 	  	  	  	  	  	  	 EstimatedSigma 	  	 float,
 	  	  	  	  	  	  	 ProcessMean 	  	  	 float, 	 -- Average of the individuals
 	  	  	  	  	  	  	 ProcessMinimum 	  	 float, 	 -- Minimum of the individuals
 	  	  	  	  	  	  	 ProcessMaximum 	  	 float, 	 -- Maximum of the individuals
 	  	  	  	  	  	  	 ProcessSigma 	  	 float, 	 -- Standard Deviation of the individuals
 	  	  	  	  	  	  	 LCL 	  	  	  	  	 float,
 	  	  	  	  	  	  	 UCL 	  	  	  	  	 float,
 	  	  	  	  	  	  	 NumberOfPoints 	  	 int,
 	  	  	  	  	  	  	 Cr 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Cp 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Cpl 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Cpu 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Cpk 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Cpm 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Pp 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Ppl 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Ppu 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Ppk 	  	  	  	  	 float,
 	  	  	  	  	  	  	 Zlsl 	  	  	  	 float,
 	  	  	  	  	  	  	 Zusl 	  	  	  	 float,
 	  	  	  	  	  	  	 Zt 	  	  	  	  	 float)
-- Limits
DECLARE @Limits TABLE ( 	 ProdId 	  	  	 int,
 	  	  	  	  	  	 Size 	  	  	 int,
 	  	  	  	  	  	 XCL 	  	  	  	 float,
 	  	  	  	  	  	 XCLd 	  	  	 float,
 	  	  	  	  	  	 XUCL 	  	  	 float,
 	  	  	  	  	  	 XLCL 	  	  	 float,
 	  	  	  	  	  	 MRSCL 	  	  	 float,
 	  	  	  	  	  	 MRSCLd 	  	  	 float,
 	  	  	  	  	  	 MRSUCL 	  	  	 float,
 	  	  	  	  	  	 MRSLCL 	  	  	 float,
 	  	  	  	  	  	 PRIMARY KEY(ProdId, Size))
DECLARE @Alarms TABLE ( 	 AlarmId 	  	 int IDENTITY(1,1),
 	  	  	  	  	  	 SubgroupId 	 int,
 	  	  	  	  	  	 AlarmOrder 	 int,
 	  	  	  	  	  	 AlarmText 	 nvarchar(1000),
 	  	  	  	  	  	 PRIMARY KEY (SubgroupId, AlarmId))
/******************************************************************************
** 	  	  	  	  	  	  	  	 INITIALIZATION 	  	  	  	  	  	  	  	  **
******************************************************************************/
-- Initialize
IF @InTimeZone = '' SELECT @InTimeZone = NULL
SELECT @StartTime = dbo.fnServer_CmnConvertToDBTime(@StartTime,@InTimeZone)
SELECT @EndTime = dbo.fnServer_CmnConvertToDBTime(@EndTime,@InTimeZone)
SELECT 	 @DTId 	  	  	  	 = 0,
 	  	 @SpecParmId 	  	  	 = 13
-- Clean arguments
SELECT 	 @NumberOfPoints 	 = isnull(@NumberOfPoints, 0),
 	  	 @CrewList 	  	 = nullif(ltrim(rtrim(@CrewList)), ''),
 	  	 @ShiftList 	  	 = nullif(ltrim(rtrim(@ShiftList)), ''),
 	  	 @ProductList 	 = nullif(ltrim(rtrim(@ProductList)), ''),
 	  	 @OrderList 	  	 = nullif(ltrim(rtrim(@OrderList)), ''),
 	  	 @EventList 	  	 = nullif(ltrim(rtrim(@EventList)), ''),
 	  	  @GoodValue 	  	  	 = nullif(ltrim(rtrim(@GoodValue)), ''), --MK
 	  	  @GoodValueMin 	  	 = NULL, --MK
 	  	  @GoodValueMax 	  	 = NULL --MK
-- Validate @ChartType and @SubgroupSize arguments --MK
IF  	  @ChartType = 4 AND (@SubgroupSize < 2 OR @SubgroupSize > 25) AND @SubgroupType = 1
  	  BEGIN
  	  SELECT 'Error: Range chart needs a subgroup size >= 2 and <= 25'
  	  RETURN(-102)
  	  END
ELSE IF @ChartType = 5  AND @SubgroupType = 1 AND @SubgroupSize < 2
  	  BEGIN
  	  SELECT 'Error: Sigma chart needs a subgroup size > 2'
  	  RETURN(-103)
  	  END
ELSE IF @ChartType = 3  AND @SubgroupType = 1 AND @SubgroupSize < 1
  	  BEGIN
  	  SELECT 'Error: P chart needs a subgroup size > 1'
  	  RETURN(-104)
  	  END
ELSE IF @ChartType = 2  AND @SubgroupType = 1 AND @SubgroupSize < 1
  	  BEGIN
  	  SELECT 'Error: U chart needs a subgroup size > 1'
  	  RETURN(-105)
  	  END
ELSE IF @ChartType = 6
  	  BEGIN
  	  SELECT @SubgroupSize = 1
  	  END
-- Get unit and other attributes for the variable
SELECT @PUId    = COALESCE(pu.master_unit,pu.pu_id),--PU_Id,
       @ETId    = Event_Type,
       @DTId    = Data_Type_Id,
       @SPCVarTypeId  = SPC_Calculation_Type_Id,
       @SPCChildVarTypeId = SPC_Group_Variable_Type_Id,
       @DType_Id   = Data_Type_Id,
 	    @PreVarId = Var_Precision 
    FROM dbo.Variables v WITH (NOLOCK)
     join dbo.prod_units pu with(nolock) on pu.pu_id = v.pu_id
        WHERE v.Var_Id = @VariableId
-- Verify that the variable is numeric, else RETURN error
IF @DTId NOT IN (1, 2) AND @ChartType IN (4, 5, 6) /*MK*/
 	 BEGIN
 	 SELECT 'Error: Non-numeric data type'
 	 RETURN(-100)
 	 END
-- If the variable is an SPC variable get the child moving/range/standard deviation variables and Individuals
IF @SPCVarTypeId IS NOT NULL
 	 BEGIN
 	 IF @SPCVarTypeId IN ( 	 4, 	 -- Xbar-R
 	  	  	  	  	  	  	 5, 	 -- Xbar-S
 	  	  	  	  	  	  	 6, 	 -- Xbar-MR
 	  	  	  	  	  	  	 2,  	 -- U
 	  	  	  	  	  	  	 3) 	 --P
 	  	 BEGIN
 	  	 SELECT @RVarId = Var_Id,@PreRVarId = Var_Precision 
 	  	 FROM dbo.Variables WITH (NOLOCK)
 	  	 WHERE 	 PU_Id 	 = @PUId
 	  	  	  	 AND PVar_Id = @VariableId
 	  	  	  	 AND SPC_Group_Variable_Type_Id = 2 	 -- Calculated Range
 	  	 SELECT @SVarId = Var_Id,@PreSVarId = Var_Precision 
 	  	 FROM dbo.Variables WITH (NOLOCK)
 	  	 WHERE 	 PU_Id 	 = @PUId
 	  	  	  	 AND PVar_Id = @VariableId
 	  	  	  	 AND SPC_Group_Variable_Type_Id = 3 	 -- Calculated Standard Deviation
 	  	 SELECT @MRVarId = Var_Id,@PreMRVarId = Var_Precision 
 	  	 FROM dbo.Variables WITH (NOLOCK)
 	  	 WHERE 	 PU_Id 	 = @PUId
 	  	  	  	 AND PVar_Id = @VariableId
 	  	  	  	 AND SPC_Group_Variable_Type_Id = 4 	 -- Calculated Range
 	  	 INSERT @Individuals (VarId)
 	  	 SELECT Var_Id
 	  	 FROM dbo.Variables WITH (NOLOCK)
 	  	 WHERE 	 PU_Id 	 = @PUId
 	  	  	  	 AND PVar_Id = @VariableId
 	  	  	  	 AND SPC_Group_Variable_Type_Id = 1
  	    	    	    	  AND Data_Type_Id IN (1, 2) 	  	 --MK. Do calc only on numeric
 	  	 END
 	 ELSE
 	  	 BEGIN
 	  	 SELECT 'Error: Unsupported SPC Variable'
 	  	 RETURN(-101)
 	  	 END
 	 END
-- Get site parameters
SELECT 	 @SpecParm = dbo.fnServer_CmnGetParameter( 	 @SpecParmId,
 	  	  	  	  	  	  	  	  	  	  	  	  	 NULL,
 	  	  	  	  	  	  	  	  	  	  	  	  	 NULL,
 	  	  	  	  	  	  	  	  	  	  	  	  	 1,NULL)
/******************************************************************************
** 	  	  	  	  	  	  	  	 GET FILTER DATA 	  	  	  	  	  	  	  	  **
******************************************************************************/
-- Products
IF @ProductList IS NOT NULL
 	 BEGIN
 	 INSERT @Products (ProdId)
 	 SELECT Id
 	 FROM dbo.fnCmn_IdListToTable('Products',@ProductList, ',')
 	 END
--Product to be shown on Histogram
-- Shifts
IF @ShiftList IS NOT NULL
 	 BEGIN
 	 INSERT @Shifts (ShiftDesc)
 	 SELECT Value
 	 FROM dbo.fnLocal_CmnParseList(@ShiftList, ',')
 	 END
-- Crews
IF @CrewList IS NOT NULL
 	 BEGIN
 	 INSERT @Crews (CrewDesc)
 	 SELECT Value
 	 FROM dbo.fnLocal_CmnParseList(@CrewList, ',')
 	 END
-- Process Orders
IF @OrderList IS NOT NULL
 	 BEGIN
 	 INSERT @Orders (PPId)
 	 SELECT Id
 	 FROM dbo.fnCmn_IdListToTable('Production_Plan', @OrderList, ',')
 	 END
-- Events
IF @ETId = 1
 	 BEGIN
 	 INSERT @Events (EventId)
 	 SELECT 	 Id
 	 FROM dbo.fnCmn_IdListToTable('Events', @EventList, ',')
 	 Declare @EventNum  varchar(8000)
 	 Select @EventNum = stuff((Select ',' + e.Event_num from Events e join @Events ev on e.Event_Id= ev.EventId FOR XML PATH('')),1,1,'')
 	 END
 	 
ELSE
 	 BEGIN
 	 SET @EventList = NULL
 	 END
--Good Value
IF CHARINDEX ('~', @GoodValue) > 0 
 	 BEGIN
 	 IF ISNUMERIC(SUBSTRING(@GoodValue, 1, CHARINDEX ('~', @GoodValue) - 1)) = 1
 	  	 SET @GoodValueMin = CAST(SUBSTRING(@GoodValue, 1, CHARINDEX ('~', @GoodValue) - 1) AS float)
 	 
 	 IF ISNUMERIC(REVERSE(SUBSTRING(REVERSE(@GoodValue), 1, CHARINDEX ('~', (REVERSE(@GoodValue))) - 1))) = 1
 	  	 SET @GoodValueMax = CAST(REVERSE(SUBSTRING(REVERSE(@GoodValue), 1, CHARINDEX ('~', (REVERSE(@GoodValue))) - 1)) AS float)
 	 END
/******************************************************************************
** 	  	  	  	  	  	  	  	 GET BASE DATA 	  	  	  	  	  	  	  	  **
******************************************************************************/
--------------------------  NUMBER OF POINTS  ---------------------------------
-- Retrieve the base data set based on the number of data points
-- When retrieving by number of data points, all the filters have to be applied
-- simultaneously to get the right result
IF @NumberOfPoints > 0
 	 BEGIN
 	 SELECT 	 @sEndTime 	  	 = char(39) + convert(nvarchar(25), @EndTime, 120) + char(39),
 	  	  	 @sStartTime 	  	 = char(39) + convert(nvarchar(25), @StartTime, 120) + char(39),
 	  	  	 @sPUId 	  	  	 = ltrim(str(@PUId, 10, 0)),
 	  	  	 @sVariableId 	 = ltrim(str(@VariableId, 10, 0)),
 	  	  	 @CrewList 	  	 = char(39) + replace(@CrewList, ',', char(39) + ',' + char(39)) + char(39),
 	  	  	 @ShiftList 	  	 = char(39) + replace(@ShiftList, ',', char(39) + ',' + char(39)) + char(39)
    ----------------  NUMBER OF POINTS: PRODUCTION EVENT  ---------------------
 	 IF @ETId = 1
 	  	 BEGIN
 	  	 SET @sSQL = 	 'SELECT TOP ' + ltrim(str(@NumberOfPoints, 25,0)) + ' '
 	  	  	  	 + 	  	  	 't.Test_Id, '
 	  	  	  	 + 	  	  	 't.Result_On, '
 	  	  	  	 + 	  	  	 't.Result, '
 	  	  	  	 + 	  	  	 'coalesce(e.Applied_Product, ps.Prod_Id), '
 	  	  	  	 + 	  	  	 't.Event_Id '
 	  	  	  	 + 	 'FROM dbo.Events e WITH (NOLOCK) '
 	  	  	  	 + 	  	 'LEFT JOIN dbo.Production_Starts ps 	 WITH (NOLOCK) '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	 'ON 	 ps.PU_Id = ' + @sPUId + ' '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	 'AND e.Timestamp >= ps.Start_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	 'AND ( 	 e.Timestamp < ps.End_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	  	 'OR ps.End_Time IS NULL) '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	 'AND ps.Start_Time < ' + @sEndTime + ' '
 	  	  	  	 + CASE
 	  	  	  	  	 WHEN 	 @ShiftList IS NOT NULL
 	  	  	  	  	  	  	 OR @CrewList IS NOT NULL THEN
 	  	  	  	  	  	 'LEFT JOIN dbo.Crew_Schedule cs 	 WITH (NOLOCK) '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	 'ON 	 cs.PU_Id = ' + @sPUId + ' '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	 'AND e.Timestamp > cs.Start_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	 'AND e.Timestamp <= cs.End_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	 'AND cs.Start_Time < ' + @sEndTime + ' '
 	  	  	  	  	 ELSE ''
 	  	  	  	  	 END
 	  	  	  	 + CASE
 	  	  	  	  	 WHEN 	 @OrderList IS NOT NULL THEN
 	  	  	  	  	  	 'LEFT JOIN dbo.Production_Plan_Starts pps 	 WITH (NOLOCK) '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	 'ON 	 pps.PU_Id = ' + @sPUId + ' '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	  	 'AND e.Timestamp > pps.Start_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	  	 'AND e.Timestamp <= pps.End_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	  	 'AND pps.Start_Time < ' + @sEndTime + ' '
 	  	  	  	 + 	  	 'LEFT JOIN dbo.Event_Details ed 	 WITH (NOLOCK) '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	 'ON e.Event_Id = ed.Event_Id '
 	  	  	  	  	 ELSE ''
 	  	  	  	  	 END
 	  	  	  	 + 	  	 'LEFT JOIN dbo.Tests t 	 WITH (NOLOCK) '
 	  	  	  	 + 	  	  	  	  	  	  	  	 'ON 	 t.Var_Id = ' + @sVariableId + ' '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	 'AND t.Result_On = e.TimeStamp '
 	  	  	  	 + 	 'WHERE 	 e.PU_Id = ' + @sPUId + ' ' 	  	  	  	  	  	  	  	  	  	 -- MKW 2009-06-22
 	  	  	  	 + 	  	  	 'AND t.Var_Id = ' + @sVariableId + ' '
 	  	  	  	 + 	 CASE 	 WHEN @Direction = 0
 	  	  	  	  	  	  	  	 THEN 	 'AND e.TimeStamp >= ' + @sStartTime + ' '
 	  	  	  	  	  	  	 ELSE 	  	 'AND e.TimeStamp <= ' + @sEndTime + ' '
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	  	  	 'AND Result IS NOT NULL '
 	  	  	  	 + 	 CASE 	 WHEN @ProductList IS NOT NULL
 	  	  	  	  	  	  	  	 THEN 'AND coalesce(e.Applied_Product, ps.Prod_Id)  IN (' + @ProductList +') '
 	  	  	  	  	  	  	 ELSE ''
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 CASE 	 WHEN @CrewList IS NOT NULL
 	  	  	  	  	  	  	  	 THEN 'AND cs.Crew_Desc IN (' + @CrewList + ') '
 	  	  	  	  	  	  	 ELSE ''
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 CASE 	 WHEN @ShiftList IS NOT NULL
 	  	  	  	  	  	  	  	 THEN 'AND cs.Shift_Desc IN (' + @ShiftList + ') '
 	  	  	  	  	  	  	 ELSE ''
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 CASE 	 WHEN @OrderList IS NOT NULL
 	  	  	  	  	  	  	  	 THEN 'AND COALESCE(ed.PP_Id, pps.PP_Id) IN ('+ @OrderList + ') '
 	  	  	  	  	  	  	 ELSE ''
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 CASE 	 WHEN @EventList IS NOT NULL
 	  	  	  	  	  	  	  	 THEN ' AND e.Event_Id IN ('+ @EventList + ') '
 	  	  	  	  	  	  	 ELSE ''
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 CASE 	 WHEN @Direction = 0
 	  	  	  	  	  	  	  	 THEN 	 ' ORDER BY e.TimeStamp ASC'
 	  	  	  	  	  	  	 ELSE 	  	 ' ORDER BY e.TimeStamp DESC'
 	  	  	  	  	  	  	 END
 	  	 INSERT #Tests ( 	 TestId,
 	  	  	  	  	  	 Timestamp,
 	  	  	  	  	  	 Result,
 	  	  	  	  	  	 ProdId,
 	  	  	  	  	  	 EventId)
 	  	 EXEC(@sSQL)
 	  	 IF @Direction = 0 -- need to flip data sort
 	  	 BEGIN
 	  	  	 SELECT * INTO #Tests2 FROM #Tests
 	  	  	 TRUNCATE TABLE #Tests
 	  	  	 INSERT INTO #Tests(TestId,Timestamp,Result, 	 ProdId, 	 EventId)
 	  	  	  	 SELECT   	 TestId,Timestamp,Result,ProdId,EventId
 	  	  	  	 FROM #Tests2 
 	  	  	  	 ORDER BY Timestamp DESC
 	  	  	 DROP TABLE #Tests2
 	  	 END
 	  	 END
    ------------------  NUMBER OF POINTS: TIME DATA  --------------------------
 	 ELSE
 	  	 BEGIN
 	  	 SET @sSQL = 	 'SELECT TOP ' + ltrim(str(@NumberOfPoints, 25,0)) + ' '
 	  	  	  	 + 	  	  	 't.Test_Id, '
 	  	  	  	 + 	  	  	 't.Result_On, '
 	  	  	  	 + 	  	  	 't.Result, '
 	  	  	  	 + 	  	  	 'ps.Prod_Id, '
 	  	  	  	 + 	  	  	 't.Event_Id '
 	  	  	  	 + 	 'FROM dbo.Tests t WITH (NOLOCK) '
 	  	  	  	 + 	  	 'LEFT JOIN dbo.Production_Starts ps 	 WITH (NOLOCK) '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	 'ON 	 ps.PU_Id = ' + @sPUId + ' '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	 'AND t.Result_On >= ps.Start_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	 'AND ( 	 t.Result_On < ps.End_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	  	 'OR ps.End_Time IS NULL) '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	 'AND ps.Start_Time < ' + @sEndTime + ' '
 	  	  	  	 + CASE
 	  	  	  	  	 WHEN 	 @ShiftList IS NOT NULL
 	  	  	  	  	  	  	 OR @CrewList IS NOT NULL THEN
 	  	  	  	  	  	 'LEFT JOIN dbo.Crew_Schedule cs 	 WITH (NOLOCK) '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	 'ON 	 cs.PU_Id = ' + @sPUId + ' '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	 'AND t.Result_On > cs.Start_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	 'AND t.Result_On <= cs.End_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	 'AND cs.Start_Time < ' + @sEndTime + ' '
 	  	  	  	  	 ELSE ''
 	  	  	  	  	 END
 	  	  	  	 + CASE
 	  	  	  	  	 WHEN 	 @OrderList IS NOT NULL THEN
 	  	  	  	  	  	 'LEFT JOIN dbo.Production_Plan_Starts pps 	 WITH (NOLOCK) '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	 'ON 	 pps.PU_Id = ' + @sPUId + ' '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	  	 'AND t.Result_On > pps.Start_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	  	 'AND t.Result_On <= pps.End_Time '
 	  	  	  	 + 	  	  	  	  	  	  	  	  	  	  	  	  	  	 'AND pps.Start_Time < ' + @sEndTime + ' '
 	  	  	  	  	 ELSE ''
 	  	  	  	  	 END
 	  	  	  	 + 	 'WHERE 	 t.Var_Id = ' + @sVariableId + ' '
 	  	  	  	 + 	 CASE 	 WHEN @Direction = 0
 	  	  	  	  	  	  	  	 THEN 	 'AND t.Result_On >= ' + @sStartTime + ' '
 	  	  	  	  	  	  	 ELSE 	  	 'AND t.Result_On <= ' + @sEndTime + ' '
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 'AND Result IS NOT NULL '
 	  	  	  	 + 	 CASE 	 WHEN @ProductList IS NOT NULL
 	  	  	  	  	  	  	  	 THEN 'AND ps.Prod_Id IN (' + @ProductList +') '
 	  	  	  	  	  	  	 ELSE ''
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 CASE 	 WHEN @CrewList IS NOT NULL
 	  	  	  	  	  	  	  	 THEN 'AND cs.Crew_Desc IN (' + @CrewList + ') '
 	  	  	  	  	  	  	 ELSE ''
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 CASE 	 WHEN @ShiftList IS NOT NULL
 	  	  	  	  	  	  	  	 THEN 'AND cs.Shift_Desc IN (' + @ShiftList + ') '
 	  	  	  	  	  	  	 ELSE ''
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 CASE 	 WHEN @OrderList IS NOT NULL
 	  	  	  	  	  	  	  	 THEN 'AND pps.PP_Id IN ('+ @OrderList + ') '
 	  	  	  	  	  	  	 ELSE ''
 	  	  	  	  	  	  	 END
 	  	  	  	 + 	 CASE 	 WHEN @Direction = 0
 	  	  	  	  	  	  	  	 THEN 	 ' ORDER BY t.Result_On ASC'
 	  	  	  	  	  	  	 ELSE 	  	 ' ORDER BY t.Result_On DESC'
 	  	  	  	  	  	  	 END
 	  	 INSERT #Tests ( 	 TestId,
 	  	  	  	  	  	 Timestamp,
 	  	  	  	  	  	 Result,
 	  	  	  	  	  	 ProdId,
 	  	  	  	  	  	 EventId)
 	  	 EXEC(@sSQL)
 	  	 IF @Direction = 0 -- need to flip data sort
 	  	 BEGIN
 	  	  	 SELECT * INTO #Tests3 FROM #Tests
 	  	  	 TRUNCATE TABLE #Tests
 	  	  	 INSERT INTO #Tests(TestId,Timestamp,Result, 	 ProdId, 	 EventId)
 	  	  	  	 SELECT   	 TestId,Timestamp,Result,ProdId,EventId
 	  	  	  	 FROM #Tests3 
 	  	  	  	 ORDER BY Timestamp DESC
 	  	  	 DROP TABLE #Tests3
 	  	 END
 	  	 END
 	 END
-----------------------------  TIME RANGE  ------------------------------------
-- Retrieve the base data set based on the selected time range
-- When retrieving by time, can break the filters up into smaller chunks for 
-- better performance
ELSE
 	 BEGIN
    ------------------  TIME RANGE: PRODUCTION EVENT  -------------------------
 	 -- Retrieve base data
 	 IF @ETId = 1 	 -- Production Event
 	  	 BEGIN
 	  	 INSERT #Tests ( 	 TestId,
 	  	  	  	  	  	 Timestamp,
 	  	  	  	  	  	 Result,
 	  	  	  	  	  	 ProdId,
 	  	  	  	  	  	 EventId)
 	  	 SELECT 	 t.Test_Id,
 	  	  	  	 e.Timestamp,
 	  	  	  	 t.Result,
 	  	  	  	 coalesce(e.Applied_Product, r.ProdId),
 	  	  	  	 t.Event_Id
 	  	 FROM dbo.Events e WITH (NOLOCK)
 	  	  	 JOIN dbo.fnCmn_GetTimeRanges( 	 @PUId,
 	  	  	  	  	  	  	  	  	  	  	 @StartTime,
 	  	  	  	  	  	  	  	  	  	  	 @EndTime,
 	  	  	  	  	  	  	  	  	  	  	 Null,
 	  	  	  	  	  	  	  	  	  	  	 @ShiftList,
 	  	  	  	  	  	  	  	  	  	  	 @CrewList,
 	  	  	  	  	  	  	  	  	  	  	 @OrderList,
 	  	  	  	  	  	  	  	  	  	  	 @NPFilter) r ON e.Timestamp >= r.StartTime
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 AND e.Timestamp < r.EndTime
 	  	  	 LEFT JOIN dbo.Event_Details ed ON e.Event_Id = ed.Event_Id
 	  	  	 LEFT JOIN dbo.Tests t 	 WITH (NOLOCK)
 	  	  	  	  	  	  	  	  	 ON 	 t.Var_Id = @VariableId
 	  	  	  	  	  	  	  	  	  	 AND t.Result_On = e.TimeStamp
 	  	 WHERE 	 e.PU_Id = @PUId
 	  	  	  	 AND e.TimeStamp >= @StartTime
 	  	  	  	 AND e.TimeStamp < @EndTime
 	  	  	  	 AND t.Result IS NOT NULL
 	  	  	  	 AND ( 	 e.Event_Id IN ( 	 SELECT EventId
 	  	  	  	  	  	  	  	  	  	 FROM @Events)
 	  	  	  	  	  	 OR @EventList IS NULL)
 	  	  	  	 AND ed.PP_Id IS NULL
 	  	 ORDER BY e.Timestamp DESC 	  	 -- This is important for Time-Series subgroups
 	  	 -- For @OrderList also check for Event_Details.PP_Id = this is an inclusive OR 
 	  	 -- b/c the other data will already be filtered by the time ranges
 	  	 IF @OrderList IS NOT NULL
 	  	  	 BEGIN
 	  	  	 INSERT #Tests ( 	 TestId,
 	  	  	  	  	  	  	 Timestamp,
 	  	  	  	  	  	  	 Result,
 	  	  	  	  	  	  	 ProdId,
 	  	  	  	  	  	  	 EventId)
 	  	  	 SELECT 	 t.Test_Id,
 	  	  	  	  	 e.Timestamp,
 	  	  	  	  	 t.Result,
 	  	  	  	  	 coalesce(e.Applied_Product, ps.Prod_Id),
 	  	  	  	  	 t.Event_Id
 	  	  	 FROM dbo.Events e WITH (NOLOCK)
 	  	  	  	 JOIN dbo.Event_Details ed WITH (NOLOCK)
 	  	  	  	  	  	  	  	  	  	  	 ON e.Event_Id = ed.Event_Id
 	  	  	  	 LEFT JOIN dbo.Production_Starts ps ON ps.PU_Id = e.PU_Id
 	  	  	  	  	  	  	  	  	  	  	  	  	  	 AND e.TimeStamp >= ps.Start_Time
 	  	  	  	  	  	  	  	  	  	  	  	  	  	 AND ( 	 e.Timestamp < ps.End_Time
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 OR ps.End_Time IS NULL)
 	  	  	  	 LEFT JOIN dbo.Tests t 	 WITH (NOLOCK)
 	  	  	  	  	  	  	  	  	  	 ON 	 t.Var_Id = @VariableId
 	  	  	  	  	  	  	  	  	  	  	 AND t.Result_On = e.TimeStamp
 	  	  	  	  	 LEFT JOIN #Tests t2 ON 	 t.Test_Id = t2.TestId
 	  	  	 WHERE 	 e.PU_Id = @PUId
 	  	  	  	  	 AND e.TimeStamp >= @StartTime
 	  	  	  	  	 AND e.TimeStamp < @EndTime
 	  	  	  	  	 AND t.Result IS NOT NULL
 	  	  	  	  	 AND ed.PP_Id IN ( 	 SELECT PPId
 	  	  	  	  	  	  	  	  	  	 FROM @Orders)
 	  	  	  	  	 AND t2.TestId IS NULL 	 -- Only insert if not already found in previous query
 	  	  	 ORDER BY e.Timestamp DESC 	  	 -- This is important for Time-Series subgroups
 	  	  	 END
 	  	 END
    ----------------------  TIME RANGE: TIME DATA  ----------------------------
 	 ELSE
 	  	 BEGIN
 	  	 INSERT #Tests ( 	 TestId,
 	  	  	  	  	  	 Timestamp,
 	  	  	  	  	  	 Result,
 	  	  	  	  	  	 ProdId,
 	  	  	  	  	  	 EventId)
 	  	 SELECT 	 t.Test_Id,
 	  	  	  	 t.Result_On,
 	  	  	  	 t.Result,
 	  	  	  	 r.ProdId,
 	  	  	  	 t.Event_Id
 	  	 FROM dbo.Tests t WITH (NOLOCK)
 	  	  	 JOIN dbo.fnCmn_GetTimeRanges( 	 @PUId,
 	  	  	  	  	  	  	  	  	  	  	 @StartTime,
 	  	  	  	  	  	  	  	  	  	  	 @EndTime,
 	  	  	  	  	  	  	  	  	  	  	 @ProductList,
 	  	  	  	  	  	  	  	  	  	  	 @ShiftList,
 	  	  	  	  	  	  	  	  	  	  	 @CrewList,
 	  	  	  	  	  	  	  	  	  	  	 @OrderList,
 	  	  	  	  	  	  	  	  	  	  	 @NPFilter) r ON t.Result_On >= r.StartTime
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 AND t.Result_On < r.EndTime
 	  	 WHERE 	 t.Var_Id = @VariableId
 	  	  	  	 AND t.Result_On >= @StartTime
 	  	  	  	 AND t.Result_On < @EndTime
 	  	  	  	 AND Result IS NOT NULL
 	  	 ORDER BY Result_On DESC 	  	 -- This is important for Time-Series subgroups
 	  	 END
 	 END
/*Final cleanup of Products*/
IF EXISTS(Select 1 FROM @Products)
BEGIN
 	 DELETE FROM #Tests
 	  	  WHERE ProdId Not IN (SELECT ProdId FROM @Products)
END
/******************************************************************************
** 	  	  	  	  	  	  	  	 SUBGROUPS 	  	  	  	  	  	  	  	  	  **
******************************************************************************/
------------------------  VARIABLE SUBGROUPS  ---------------------------------
IF 	 @SubgroupType = 0 AND @SPCVarTypeId IS NOT NULL -- SPC variable
 	 BEGIN
 	 -- Get subgroup size
 	 SELECT @SubGroupSize = COUNT(Var_Id)
 	 FROM dbo.Variables WITH (NOLOCK)
 	 WHERE 	 PU_Id = @PUId
 	  	  	 AND PVar_Id = @VariableId
 	  	  	 AND SPC_Group_Variable_Type_Id = 1 	 -- Individual
 	 INSERT #SubgroupIndex (XId)
 	 SELECT t.XId
 	 FROM #Tests t
 	 ORDER BY 	 t.ProdId,
 	  	  	  	 t.TimeStamp
  	 -- Insert the subgroup data
 	 INSERT #Subgroups ( 	 SubgroupId,
 	  	  	  	  	  	 TestId,
 	  	  	  	  	  	 R_TestId,
 	  	  	  	  	  	 S_TestId,
 	  	  	  	  	  	 MR_TestId,
 	  	  	  	  	  	 Timestamp,
 	  	  	  	  	  	 Result,
 	  	  	  	  	  	 ProdId,
 	  	  	  	  	  	 R,
 	  	  	  	  	  	 S,
 	  	  	  	  	  	 MR,
 	  	  	  	  	  	 UChart,
 	  	  	  	  	  	 PChart,
 	  	  	  	  	  	 Size)
 	 SELECT 	 si.SubgroupIndexId,
 	  	  	 T.TestId,
 	  	  	 R.Test_Id,
 	  	  	 s.Test_Id,
 	  	  	 mr.Test_Id,
 	  	  	 t.Timestamp,
 	  	  	 t.Result,
 	  	  	 t.ProdId,
 	  	  	 r.Result,
 	  	  	 s.Result,
 	  	  	 mr.Result,
  	    	    	  CASE @ChartType WHEN 2 THEN t.Result ELSE NULL END, --MK
  	    	    	  CASE @ChartType WHEN 3 THEN t.Result ELSE NULL END, --MK
 	  	  	 @SubgroupSize
 	 FROM #SubgroupIndex si 
 	  	 LEFT JOIN #Tests t ON si.XId = t.XId
 	  	 LEFT JOIN dbo.Tests r 	 WITH (NOLOCK)
 	  	  	  	  	  	  	  	 ON 	 r.Var_Id = @RVarId
 	  	  	  	  	  	  	  	  	 AND r.Result_On = t.Timestamp
 	  	 LEFT JOIN dbo.Tests s 	 WITH (NOLOCK)
 	  	  	  	  	  	  	  	 ON 	 s.Var_Id = @SVarId
 	  	  	  	  	  	  	  	  	 AND s.Result_On = t.Timestamp
 	  	 LEFT JOIN dbo.Tests mr 	 WITH (NOLOCK)
 	  	  	  	  	  	  	  	 ON 	 mr.Var_Id = @MRVarId
 	  	  	  	  	  	  	  	  	 AND mr.Result_On = t.Timestamp
 	 -- For report raw data, update the subgroupid
 	 UPDATE t
 	 SET SubgroupId = SubgroupIndexId
 	 FROM #Tests t
 	  	 JOIN #SubgroupIndex si ON t.XId = si.XId
 	 END 	 
------------------------  TIME-SERIES SUBGROUPS  ---------------------------------
ELSE
 	 BEGIN
 	 IF @SubgroupType = 0
 	  	 BEGIN
 	  	 SET @SubgroupSize = 1
 	  	 END
 	 -- Get the products so we can divide up the subgroups by product
 	 INSERT @TestProducts (ProdId)
 	 SELECT ProdId
 	 FROM #Tests
 	 GROUP BY ProdId
 	 SELECT 	 @Rows 	  	  	  	  	 = @@ROWCOUNT,
 	  	  	 @Row 	  	  	  	  	 = 0,
 	  	  	 @SubgroupIndexFillId 	 = 0
 	 WHILE @Row < @Rows
 	  	 BEGIN
 	  	 SELECT @Row = @Row + 1
 	  	 SELECT 	 @ProdId = ProdId
 	  	 FROM @TestProducts
 	  	 WHERE TPId = @Row
 	  	 -- Divide up the tests into subgroups
 	  	 INSERT #SubgroupIndex (XId)
 	  	 SELECT t.XId
 	  	 FROM #Tests t
 	  	 WHERE t.ProdId = @ProdId
 	  	 ORDER BY t.TimeStamp DESC
 	  	 -- Advance the starting index of the subgroups so the subgroups start fresh on a new product
 	  	 SELECT @SubgroupIndexFill = MAX(SubgroupIndexId) % @SubgroupSize - 1
 	  	 FROM #SubgroupIndex
 	  	 SELECT @Count = 0
 	  	 WHILE ( @Count < @SubgroupIndexFill)
 	  	  	 BEGIN
 	  	  	 SELECT @SubgroupIndexFillId = @SubgroupIndexFillId - 1
 	  	  	 INSERT #SubgroupIndex (XId)
 	  	  	 VALUES (@SubgroupIndexFillId)
 	  	  	 SELECT @Count = @Count + 1
 	  	  	 END
 	  	 END
 	 IF @SubgroupSize = 1  AND @ChartType = 6 --MK
 	  	 BEGIN
 	  	 -- Create the subgroups and calculate the moving range
 	  	 -- Not possible to calculate range and sigma
 	  	 INSERT #Subgroups ( 	 SubgroupId,
 	  	  	  	  	  	  	 TestId,
 	  	  	  	  	  	  	 TimeStamp,
 	  	  	  	  	  	  	 Result,
 	  	  	  	  	  	  	 ProdId,
 	  	  	  	  	  	  	 MR,
 	  	  	  	  	  	  	 Size)
 	  	 SELECT 	 si1.SubgroupIndexId,
 	  	  	  	 Coalesce(t1.testid,t2.testid),
 	  	  	  	 t1.Timestamp,
 	  	  	  	 t1.Result,
 	  	  	  	 t1.ProdId,
 	  	  	  	 ABS(CONVERT(float, t1.Result) - CONVERT(float, t2.Result)),
 	  	  	  	 @SubgroupSize
 	  	 FROM #SubgroupIndex si1 
 	  	  	 LEFT JOIN #Tests t1 ON si1.XId = t1.XId
 	  	  	  	 LEFT JOIN #SubgroupIndex si2 ON si1.SubgroupIndexId = si2.SubgroupIndexId - 1
 	  	  	  	  	 LEFT JOIN #Tests t2 ON si2.XId = t2.XId
 	  	 WHERE t1.ProdId = t2.ProdId
 	  	 
/*-----------------Ramesh, Fix for the bug n-1 records -----------------------*/
INSERT #Subgroups(SubgroupId,Timestamp,Result,ProdId,MR,Size,TestId)
SELECT 	 Top 1 si1.SubgroupIndexId,
 	  	  	  	 t1.Timestamp,
 	  	  	  	 t1.Result,
 	  	  	  	 t1.ProdId,
 	  	  	  	 Null, -- Marty (11/7/14) Replace 0 with null to prevent incorrect MRBar calculation
 	  	  	  	 @SubgroupSize,
 	  	  	  	 t1.TestId 
 	  	  	  	 FROM #SubgroupIndex si1 
 	  	  	 JOIN #Tests t1 ON si1.XId = t1.XId
 	  	  	 Order by si1.SubgroupIndexId desc
/*---------------------------------------------------------*/ 	  	 
 	  	 UPDATE t
 	  	 SET SubgroupId = SubgroupIndexId
 	  	 FROM #Tests t
 	  	  	 JOIN #SubgroupIndex si ON t.XId = si.XId
 	  	 END
 	 ELSE IF  @ChartType = 4 OR @ChartType = 5
 	  	 BEGIN
 	  	 UPDATE t
 	  	 SET SubgroupId = CASE 	 WHEN si.SubgroupIndexId % @SubgroupSize <> 0 THEN
 	  	  	  	  	  	  	  	  	  	 si.SubgroupIndexId / @SubgroupSize + 1
 	  	  	  	  	  	  	  	  	 ELSE
 	  	  	  	  	  	  	  	  	  	 si.SubgroupIndexId / @SubgroupSize
 	  	  	  	  	  	  	  	  	 END
 	  	 FROM #Tests t
 	  	  	 JOIN #SubgroupIndex si ON t.XId = si.XId
 	  	 -- Insert the subgroup data
 	  	 INSERT #Subgroups ( 	 SubgroupId,
 	  	  	  	  	  	  	 Timestamp,
 	  	  	  	  	  	  	 Result,
 	  	  	  	  	  	  	 ProdId,
 	  	  	  	  	  	  	 R,
 	  	  	  	  	  	  	 S,
 	  	  	  	  	  	  	 Size)
 	  	 SELECT 	 SubgroupId,
 	  	  	  	 MAX(t.Timestamp),
 	  	  	  	 AVG(CONVERT(float,t.Result)),
 	  	  	  	 ProdId,
 	  	  	  	 MAX(CONVERT(float,t.Result))-MIN(CONVERT(float,t.Result)),
 	  	  	  	 STDEV(CONVERT(float,t.Result)), 	  	  	  	  	 -- Does it need STDEVP? 	  	 
 	  	  	  	 COUNT(XId) 
 	  	  	  	  
 	  	 FROM #Tests t
 	  	 GROUP BY 	 SubgroupId,
 	  	  	  	  	 ProdId
 	  	 HAVING COUNT(XId) = @SubgroupSize 	  	 -- MKW 2009-05-25
 	  	 ORDER BY  SubgroupId
 	  	 
 	 
 	  	 END
 	 ELSE IF @ChartType = 2 OR @ChartType = 3
  	    	  BEGIN
 	    	  UPDATE t
  	    	  SET SubgroupId = CASE  	  WHEN si.SubgroupIndexId % @SubgroupSize <> 0 THEN
  	    	    	    	    	    	    	    	    	    	  si.SubgroupIndexId / @SubgroupSize + 1
  	    	    	    	    	    	    	    	    	  ELSE
  	    	    	    	    	    	    	    	    	    	  si.SubgroupIndexId / @SubgroupSize
  	    	    	    	    	    	    	    	    	  END
  	    	  FROM #Tests t
  	    	    	  JOIN #SubgroupIndex si ON t.XId = si.XId
  	    	  
  	    	  
  	    	  ------------------------  For U\P CHARTS NEED TO DETECT # OF DEFECTS MK---------------------------------
  	  	  --Goodvalue is null, not passed from form, so we take spec limits, reject
  	  	  --IF @GoodValue IS NULL
  	  	  	 --BEGIN
  	  	  	 
 	  	  	 Select @sSQL = '', @sGoodValueMin = '', @sGoodValueMax = '' 
 	 
  	  	  	  IF @DType_Id IN (1, 2) --Numeric
  	  	  	  BEGIN
 	  	  	  	 -- Need to find a range. If good value is passed from the form used it, no - take limits from var_spec
 	  	  	  	 IF @GoodValue IS NULL
 	  	  	  	  	 BEGIN
 	  	  	  	  	 SELECT @sGoodValueMin = 'CONVERT(float, vs.L_Reject)', @sGoodValueMax = 	 'CONVERT(float, vs.U_Reject)'
 	  	  	  	  	 END
 	  	  	  	 ELSE
 	  	  	  	  	 BEGIN
 	  	  	  	  	 IF @GoodValueMin IS NULL 
 	  	  	  	  	  	 SET @sGoodValueMin = 'CONVERT(float, vs.L_Reject)' 
 	  	  	  	  	 ELSE 
 	  	  	  	  	  	 SET @sGoodValueMin = CONVERT(VARCHAR, @GoodValueMin)
 	  	  	  	  	 IF @GoodValueMax IS NULL 
 	  	  	  	  	  	 SET @sGoodValueMax = 'CONVERT(float, vs.U_Reject)' 
 	  	  	  	  	 ELSE 
 	  	  	  	  	  	 SET @sGoodValueMax = CONVERT(VARCHAR, @GoodValueMax)
 	  	  	  	  	 
 	  	  	  	  	 END 	  	  	  
  	  	  	  	 --defect is 1 if result is out of spec, otherwise 0.
 	  	   	  	 SET @sSQL = 'UPDATE t '
  	  	  	  	  + 'SET Defect = CASE WHEN CONVERT(float, t.Result) > ' + @sGoodValueMax + ' THEN 1  
  	  	  	  	  	  	  	  	  	 ELSE 
  	  	  	  	  	  	  	  	  	  	 CASE WHEN CONVERT(float, t.Result) < ' + @sGoodValueMin + ' THEN 1 
  	  	  	  	  	  	  	  	  	  	 ELSE 0 
  	  	  	  	  	  	  	  	  	  	 END 
  	  	  	  	  	  	  	  	  	 END'
  	  	  	  	  + ' FROM #Tests t
  	    	  	  	 LEFT JOIN dbo.Var_Specs vs WITH (NOLOCK)
  	    	    	    	    	    	    	    	    	  	 ON vs.Var_Id = ' + CONVERT(varchar, @VariableId) + ' 
  	    	    	    	    	    	    	    	    	    	  	 AND vs.Prod_Id = t.ProdId
  	    	    	    	    	    	    	    	    	    	  	 AND t.TimeStamp >= vs.Effective_Date
  	    	    	    	    	    	    	    	    	    	  	 AND (t.TimeStamp < vs.Expiration_Date OR vs.Expiration_Date IS NULL) 
  	    	    	    	    	    	    	    	    	    	  	 
  	    	  	  	 -- Insert the subgroup data
  	    	  	  	 INSERT #Subgroups ( SubgroupId,
  	    	    	    	    	    	    	  	  	 Timestamp,
  	    	    	    	    	    	    	  	  	 Result,
  	    	    	    	    	    	    	  	  	 ProdId,
  	    	    	    	    	    	    	  	  	 UChart,
  	    	    	    	    	    	    	  	  	 PChart, 	 
  	    	    	    	    	    	    	  	  	 Size)
  	    	  	  	 SELECT  	 SubgroupId,
  	    	    	    	  	  	 MAX(t.Timestamp),
  	    	    	    	  	  	 AVG(CAST(t.Result AS float)),
  	    	    	    	  	  	 ProdId,
  	    	    	    	  	  	 CASE ' + CONVERT(varchar, @ChartType) + ' WHEN 2 THEN SUM(t.Defect) ELSE NULL END,
  	    	    	    	  	  	 CASE ' + CONVERT(varchar, @ChartType) + ' WHEN 3 THEN SUM(t.Defect)/' + CONVERT(varchar, @SubgroupSize) + ' ELSE NULL END,
  	    	    	    	  	  	 COUNT(XId)
  	    	  	  	 FROM #Tests t
  	    	  	  	 GROUP BY  	  SubgroupId,
  	    	    	    	    	  	  	 ProdId
  	    	  	  	 HAVING COUNT(XId) = ' + CONVERT(varchar, @SubgroupSize) + ' 	    	  /*MKW 2009-05-25*/
  	    	  	  	 ORDER BY SubgroupId '
  	    	    	    	 
  	    	    	    	 EXEC (@sSQL)   	    	    	    	    	    	  	  	  	  	 
  	  	  	  END
  	  	  	  ELSE -- Var data type is not numeric
  	  	  	  BEGIN
 	  	  	  	 -- When data type is string need to find a value. If good value is passed from the form - used it, no - take limits from var_spec
 	  	  	  	 IF @GoodValue IS NULL
 	  	  	  	  	 SELECT @sGoodValueMin = ' = UPPER(LTRIM(RTRIM(vs.L_Reject)))', @sGoodValueMax = 	 ' = UPPER(LTRIM(RTRIM(vs.U_Reject)))'
 	  	  	  	 ELSE
 	  	  	  	  	 SELECT @sGoodValueMin = ' <> ''' + UPPER(LTRIM(RTRIM(@GoodValue))) + '''', @sGoodValueMax = ' <> ''' + UPPER(LTRIM(RTRIM(@GoodValue))) + ''''
 	  	  	  	  	 
  	  	  	  	 --Defect is 1 if result = lower or upper reject, otherwise 0.
  	  	  	  	 SET @sSQL = 'UPDATE t
  	  	  	  	 SET Defect = CASE WHEN UPPER(LTRIM(RTRIM(t.Result))) ' + @sGoodValueMax + ' THEN 1 
  	  	  	  	  	  	  	  	  	 ELSE 
  	  	  	  	  	  	  	  	  	  	 CASE WHEN UPPER(LTRIM(RTRIM(t.Result))) ' + @sGoodValueMin + ' THEN 1 
  	  	  	  	  	  	  	  	  	  	 ELSE 0 
  	  	  	  	  	  	  	  	  	  	 END 
  	  	  	  	  	  	  	  	  	 END
  	  	  	  	 FROM #Tests t
  	    	  	  	 LEFT JOIN dbo.Var_Specs vs WITH (NOLOCK)
  	    	    	    	    	    	    	    	    	  	 ON vs.Var_Id = ' + CONVERT(varchar, @VariableId) + '
  	    	    	    	    	    	    	    	    	    	  	 AND vs.Prod_Id = t.ProdId
  	    	    	    	    	    	    	    	    	    	  	 AND t.TimeStamp >= vs.Effective_Date
  	    	    	    	    	    	    	    	    	    	  	 AND (t.TimeStamp < vs.Expiration_Date OR vs.Expiration_Date IS NULL)  	  	  	 
  	  	  	  
  	    	  	  	 -- Insert the subgroup data
  	    	  	  	 INSERT #Subgroups ( SubgroupId,
  	    	    	    	    	    	    	  	  	 Timestamp,
  	    	    	    	    	    	    	  	  	 Result,
  	    	    	    	    	    	    	  	  	 ProdId,
  	    	    	    	    	    	    	  	  	 UChart,
  	    	    	    	    	    	    	  	  	 PChart, 	 
  	    	    	    	    	    	    	  	  	 Size)
  	    	  	  	 SELECT  	  SubgroupId,
  	    	    	    	  	  	 MAX(t.Timestamp),
  	    	    	    	  	  	 NULL, /* We can not display not numeric value*/
  	    	    	    	  	  	 ProdId,
  	    	    	    	  	  	 CASE ' + CONVERT(varchar, @ChartType) + ' WHEN 2 THEN SUM(t.Defect) ELSE NULL END,
  	    	    	    	  	  	 CASE ' + CONVERT(varchar, @ChartType) + ' WHEN 3 THEN SUM(t.Defect)/' + CONVERT(varchar, @SubgroupSize) + ' ELSE NULL END,
  	    	    	    	  	  	 COUNT(XId)
  	    	  	  	 FROM #Tests t
  	    	  	  	 GROUP BY  	  SubgroupId,
  	    	    	    	    	  	  	 ProdId
  	    	  	  	 HAVING COUNT(XId) = ' + CONVERT(varchar, @SubgroupSize) + ' 	    	  /*MKW 2009-05-25*/
  	    	  	  	 ORDER BY SubgroupId'
  	    	    	    	 EXEC (@sSQL)
  	  	  	  END
  	  	  	 --END 	 
  	    	  END 	 
 	 END
/******************************************************************************
** 	  	  	  	  	  	 LIMITS: ControlLimitType = Fixed 	  	  	  	  	  **
******************************************************************************/
IF 	 @CLType = 0 AND @DType_Id IN (1, 2) --MK Work only with numeric limits
 	 BEGIN
 	 -- Update the data point (i.e. X) limits
 	 UPDATE s
 	 SET 	 XUSL 	 = CASE @ChartType --U/P Chart
 	  	  	  	  	 /** IF Good Value is used show the limits of it MK **/ 
 	  	  	  	  	 WHEN 2 THEN CASE WHEN @GoodValueMax IS NULL THEN vs.U_Reject ELSE @GoodValueMax END
 	  	  	  	  	 WHEN 3 THEN CASE WHEN @GoodValueMax IS NULL THEN vs.U_Reject ELSE @GoodValueMax END 	  	  	 
 	  	  	  	  	 ELSE vs.U_Reject
 	  	  	  	    END, --vs.U_Reject,
 	  	 XUCL 	 = coalesce(ltrim(str(tsd.Mean + 3 * tsd.sigma,25,@PreVarId)),vs.U_Control),
 	  	 XUWL 	 = vs.U_Warning,
 	  	 XUUL 	 = vs.U_User,
 	  	 XCL 	  	 = coalesce(ltrim(str(tsd.Mean,25,@PreVarId)),vs.Target),
 	  	 XLUL 	 = vs.L_User,
 	  	 XLWL 	 = vs.L_Warning,
 	  	 XLCL 	 = coalesce(ltrim(str(tsd.Mean - 3 * tsd.sigma,25,@PreVarId)),vs.L_Control),
 	  	 XLSL 	 = CASE @ChartType -- U/P Charts
 	  	  	  	  	 /** IF Good Value is used show the limits of it **/
 	  	  	  	  	 WHEN 2 THEN CASE WHEN @GoodValueMin IS NULL THEN vs.L_Reject ELSE @GoodValueMin END
 	  	  	  	  	 WHEN 3 THEN CASE WHEN @GoodValueMin IS NULL THEN vs.L_Reject ELSE @GoodValueMin END 	  	  	 
 	  	  	  	  	 ELSE vs.L_Reject
 	  	  	  	    END, --vs.L_Reject,
 	  	 Target 	 = vs.Target 	  	  	 -- MKW 2009-05-25
 	 FROM #Subgroups s
 	  	 Left JOIN Test_Sigma_Data tsd on tsd.Test_Id = s.TestId 
 	  	 LEFT JOIN dbo.Var_Specs vs 	 WITH (NOLOCK)
 	  	  	  	  	  	  	  	  	 ON 	 vs.Var_Id = @VariableId
 	  	  	  	  	  	  	  	  	  	 AND vs.Prod_Id = s.ProdId
 	  	  	  	  	  	  	  	  	  	 AND s.TimeStamp >= vs.Effective_Date
 	  	  	  	  	  	  	  	  	  	 AND ( 	 s.TimeStamp < vs.Expiration_Date
 	  	  	  	  	  	  	  	  	  	  	  	 OR vs.Expiration_Date IS NULL)
 	 -- Update the calculated range (R), stdev (S) or moving range (MR), U/P Charts  limits
 	 IF @SPCVarTypeId IS NOT NULL
 	  	 BEGIN
 	  	 UPDATE s
 	  	 SET 	 MRSUSL 	 = vs.U_Reject,
 	  	  	 MRSUCL 	 = coalesce(ltrim(str(tsd.Mean + 3 * tsd.sigma,25,@PreVarId)),vs.U_Control),
 	  	  	 MRSUWL 	 = vs.U_Warning,
 	  	  	 MRSUUL 	 = vs.U_User,
 	  	  	 MRSCL 	 = coalesce(ltrim(str(tsd.Mean,25,@PreVarId)),vs.Target),
 	  	  	 MRSLUL 	 = vs.L_User,
 	  	  	 MRSLWL 	 = vs.L_Warning,
 	  	  	 MRSLCL 	 = coalesce(ltrim(str(tsd.Mean - 3 * tsd.sigma,25,@PreVarId)),vs.L_Control),
 	  	  	 MRSLSL 	 = vs.L_Reject
 	  	 FROM #Subgroups s
 	  	  	 Left JOIN Test_Sigma_Data tsd on tsd.Test_Id = CASE @ChartType
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 WHEN 4 THEN s.R_TestId 
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 WHEN 5 THEN s.S_TestId
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 WHEN 6 THEN s.MR_TestId
  	    	    	    	    	    	    	    	    	    	    	    	    	    	    	  WHEN 2 THEN s.TestId
  	    	    	    	    	    	    	    	    	    	    	    	    	    	    	  WHEN 3 THEN s.TestId
  	    	    	    	    	    	    	    	    	    	    	    	    	    	    	 END
 	  	  	 LEFT JOIN dbo.Var_Specs vs 	 WITH (NOLOCK)
 	  	  	  	  	  	  	  	  	  	 ON 	 vs.Var_Id = CASE @ChartType
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 WHEN 4 THEN @RVarId
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 WHEN 5 THEN @SVarId
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 WHEN 6 THEN @MRVarId
  	    	    	    	    	    	    	    	    	    	    	    	    	    	    	  WHEN 2 THEN @VariableId
  	    	    	    	    	    	    	    	    	    	    	    	    	    	    	  WHEN 3 THEN @VariableId
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 ELSE NULL
 	  	  	  	  	  	  	  	  	  	  	  	  	  	  	 END
 	  	  	  	  	  	  	  	  	  	  	 AND vs.Prod_Id = s.ProdId
 	  	  	  	  	  	  	  	  	  	  	 AND s.TimeStamp >= vs.Effective_Date
 	  	  	  	  	  	  	  	  	  	  	 AND ( 	 s.TimeStamp < vs.Expiration_Date
 	  	  	  	  	  	  	  	  	  	  	  	  	 OR vs.Expiration_Date IS NULL)
 	  	 END
 	 END
/******************************************************************************
** 	  	  	  	  	  	 LIMITS: ControlLimitType = Calculated
** NOTES:
** 1) This chart will calculate different limits for different products
******************************************************************************/
IF @CLType = 1
 	 BEGIN
 	 -- Need to update the reject/specification limits, even though calculating
 	 -- control limits
 	 UPDATE s
 	 SET 	 XUSL 	 = CASE @ChartType --U/P Chart
 	  	  	  	  	 /** IF Good Value is used show the limits of it MK **/ 
 	  	  	  	  	 WHEN 2 THEN CASE WHEN @GoodValueMax IS NULL THEN vs.U_Reject ELSE @GoodValueMax END
 	  	  	  	  	 WHEN 3 THEN CASE WHEN @GoodValueMax IS NULL THEN vs.U_Reject ELSE @GoodValueMax END 	  	  	 
 	  	  	  	  	 ELSE vs.U_Reject
 	  	  	  	    END, --vs.U_Reject,
 	  	 XLSL 	 = CASE @ChartType -- U/P Charts
 	  	  	  	  	 /** IF Good Value is used show the limits of it **/
 	  	  	  	  	 WHEN 2 THEN CASE WHEN @GoodValueMin IS NULL THEN vs.L_Reject ELSE @GoodValueMin END
 	  	  	  	  	 WHEN 3 THEN CASE WHEN @GoodValueMin IS NULL THEN vs.L_Reject ELSE @GoodValueMin END 	  	  	 
 	  	  	  	  	 ELSE vs.L_Reject
 	  	  	  	    END, --vs.L_Reject,
 	  	 Target 	 = vs.Target
 	 FROM #Subgroups s
 	  	 LEFT JOIN dbo.Var_Specs vs 	 WITH (NOLOCK)
 	  	  	  	  	  	  	  	  	 ON 	 vs.Var_Id = @VariableId
 	  	  	  	  	  	  	  	  	  	 AND vs.Prod_Id = s.ProdId
 	  	  	  	  	  	  	  	  	  	 AND s.TimeStamp >= vs.Effective_Date
 	  	  	  	  	  	  	  	  	  	 AND ( 	 s.TimeStamp < vs.Expiration_Date
 	  	  	  	  	  	  	  	  	  	  	  	 OR vs.Expiration_Date IS NULL)
 	 WHERE @DType_Id IN (1, 2) --MK Work only with numeric limits  	    	    	    	    	    	    	    	    	    	  
 	 --------------------------  XBAR/R  ---------------------------------------
 	 IF @ChartType = 4 	 -- Xbar/R
 	  	 BEGIN
 	  	 INSERT @Limits (ProdId,
 	  	  	  	  	  	 Size,
 	  	  	  	  	  	 XCL,
 	  	  	  	  	  	 XCLd,
 	  	  	  	  	  	 MRSCL,
 	  	  	  	  	  	 MRSCLd)
 	  	 SELECT 	 s.ProdId,
 	  	  	  	 s.Size,
 	  	  	  	 s.CL,
 	  	  	  	 (s.Rbar/dbo.fnCmn_SampleSizeLookup(s.Size, 'd2'))/SQRT(s.Size),
 	  	  	  	 s.Rbar,
-- 	  	  	  	 c.d3*(s.Rbar/dbo.fnCmn_SampleSizeLookup(s.Size, 'd2'))
 	  	  	  	 dbo.fnCmn_SampleSizeLookup(s.Size, 'd3')*(s.Rbar/dbo.fnCmn_SampleSizeLookup(s.Size, 'd2'))
 	  	 FROM ( 	 SELECT 	 s.ProdId,
 	  	  	  	  	  	 s.Size,
 	  	  	  	  	  	 CL 	  	 = AVG(CONVERT(float,s.Result)),
 	  	  	  	  	  	 Rbar 	 = AVG(R)
 	  	  	  	 FROM #Subgroups s
 	  	  	  	 GROUP BY 	 ProdId,
 	  	  	  	  	  	  	 s.Size
 	  	  	  	 HAVING 	 s.Size >= 2
 	  	  	  	  	  	 AND s.Size <= 25) s
-- 	  	  	 LEFT JOIN SPC_Constants c 	 WITH (NOLOCK)
-- 	  	  	  	  	  	  	  	  	  	 ON s.Size = c.Subgroup_Size
 	  	 END
 	 ----------------------------  XBAR/S  -------------------------------------
 	 ELSE IF @ChartType = 5 -- Xbar/S
 	  	 BEGIN
 	  	 INSERT @Limits (ProdId,
 	  	  	  	  	  	 Size,
 	  	  	  	  	  	 XCL,
 	  	  	  	  	  	 XCLd,
 	  	  	  	  	  	 MRSCL,
 	  	  	  	  	  	 MRSCLd)
 	  	 SELECT 	 s.ProdId,
 	  	  	  	 s.Size,
 	  	  	  	 s.CL,
 	  	  	  	 (s.Sbar/dbo.fnCmn_SampleSizeLookup(s.Size, 'c4'))/SQRT(s.Size),
 	  	  	  	 s.Sbar,
 	  	  	  	 --Will M. 5/18/2015 changed / to * per PA help "SPC Charts" article
 	  	  	  	 CASE 	 WHEN SQUARE(dbo.fnCmn_SampleSizeLookup(s.Size, 'c4')) <> 1 THEN
 	  	  	  	  	  	  	 (s.Sbar/dbo.fnCmn_SampleSizeLookup(s.Size, 'c4'))
 	  	  	  	  	  	  	  	 *SQRT(1-SQUARE(dbo.fnCmn_SampleSizeLookup(s.Size, 'c4')))
 	  	  	  	  	  	 ELSE NULL
 	  	  	  	  	  	 END
 	  	 FROM ( 	 SELECT 	 s.ProdId,
 	  	  	  	  	  	 s.Size,
 	  	  	  	  	  	 CL 	  	 = AVG(CONVERT(float,s.Result)),
 	  	  	  	  	  	 Sbar 	 = AVG(S)
 	  	  	  	 FROM #Subgroups s
 	  	  	  	 GROUP BY 	 ProdId,
 	  	  	  	  	  	  	 s.Size
 	  	  	  	 HAVING 	 s.Size >= 2) s
-- 	  	  	 LEFT JOIN SPC_Constants c 	 WITH (NOLOCK)
-- 	  	  	  	  	  	  	  	  	  	 ON s.Size = c.Subgroup_Size
 	  	 END
 	 --------------------------  X/MR (I/MR)  ----------------------------------
 	 ELSE IF @ChartType = 6 -- X/MR
 	  	 BEGIN
 	  	 INSERT @Limits (ProdId,
 	  	  	  	  	  	 Size,
 	  	  	  	  	  	 XCL,
 	  	  	  	  	  	 XCLd,
 	  	  	  	  	  	 MRSCL,
 	  	  	  	  	  	 MRSCLd)
 	  	 SELECT 	 s.ProdId,
 	  	  	  	 s.Size,
 	  	  	  	 s.CL,
 	  	  	  	 s.MRbar/dbo.fnCmn_SampleSizeLookup(2, 'd2'),
 	  	  	  	 s.MRbar,
 	  	  	  	 s.MRbar*dbo.fnCmn_SampleSizeLookup(2, 'd3')/dbo.fnCmn_SampleSizeLookup(2, 'd2')
 	  	 FROM ( 	 SELECT 	 s.ProdId,
 	  	  	  	  	  	 s.Size,
 	  	  	  	  	  	 CL 	  	 = AVG(CONVERT(float,Result)),
 	  	  	  	  	  	 MRbar 	 = AVG(MR)
 	  	  	  	 FROM #Subgroups s
 	  	  	  	 GROUP BY 	 ProdId,
 	  	  	  	  	  	  	 s.Size) s
-- 	  	  	 LEFT JOIN SPC_Constants c 	 WITH (NOLOCK)
-- 	  	  	  	  	  	  	  	  	  	 ON c.Subgroup_Size = 2
 	  	 END
  	  --------------------------  U Chart   ----------------------------------
  	  ELSE IF @ChartType = 2 -- U Chart
  	    	  BEGIN
  	    	  IF @DType_Id IN (1, 2)
  	    	   BEGIN
  	    	  	 INSERT @Limits (ProdId,
  	    	    	    	    	    	  	 Size,
  	    	    	    	    	    	  	 XCL,
  	    	    	    	    	    	  	 XCLd,
  	    	    	    	    	    	  	 MRSCL,
  	    	    	    	    	    	  	 MRSCLd)
  	    	  	 SELECT  s.ProdId,
  	    	    	    	  	 s.Size, 
  	    	    	    	  	 s.CL, 
  	    	    	    	  	 SQRT(s.CL/s.Size),
  	    	    	    	  	 s.UBar,
  	    	    	    	  	 SQRT(s.UBar/s.Size)
  	    	  	 FROM ( SELECT  	  s.ProdId,
  	    	    	    	    	    	  	 s.Size,
  	    	    	    	    	    	  	 CL  	  = AVG(CAST(Result AS float)),
  	    	    	    	    	    	  	 UBar  	  = AVG(UChart)
  	    	    	    	  	 FROM #Subgroups s
  	    	    	    	  	 GROUP BY  	  ProdId,
  	    	    	    	    	    	    	  	 s.Size) s
 	 --  	    	    	  LEFT JOIN SPC_Constants c  	  WITH (NOLOCK)
 	 --  	    	    	    	    	    	    	    	    	    	  ON c.Subgroup_Size = 2
  	    	   
  	    	   END
  	    	  ELSE
  	    	   BEGIN
  	    	  	 INSERT @Limits (ProdId,
  	    	    	    	    	    	  	 Size,
  	    	    	    	    	    	  	 XCL,
  	    	    	    	    	    	  	 XCLd,
  	    	    	    	    	    	  	 MRSCL,
  	    	    	    	    	    	  	 MRSCLd)
  	    	  	 SELECT  s.ProdId,
  	    	    	    	  	 s.Size, 
  	    	    	    	  	 NULL, --s.CL, 
  	    	    	    	  	 NULL, --SQRT(s.CL/s.Size),
  	    	    	    	  	 s.UBar,
  	    	    	    	  	 SQRT(s.UBar/s.Size)
  	    	  	 FROM ( SELECT  	  s.ProdId,
  	    	    	    	    	    	  	 s.Size,
  	    	    	    	    	    	  	 -- MK Not Numeric --CL  	  = AVG(CAST(Result AS float)),
  	    	    	    	    	    	  	 UBar  	  = AVG(UChart)
  	    	    	    	  	 FROM #Subgroups s
  	    	    	    	  	 GROUP BY  	  ProdId,
  	    	    	    	    	    	    	  	 s.Size) s
 	 --  	    	    	  LEFT JOIN SPC_Constants c  	  WITH (NOLOCK)
 	 --  	    	    	    	    	    	    	    	    	    	  ON c.Subgroup_Size = 2  	    	   
  	    	   END
  	    	    
  	    	  END
  	  --------------------------  P Chart   ----------------------------------
  	  ELSE IF @ChartType = 3 -- P Chart
  	    	  BEGIN
  	    	   IF @DType_Id IN (1, 2)
  	    	  	 BEGIN
  	    	  	   	 INSERT @Limits (ProdId,
  	    	    	    	    	    	  Size,
  	    	    	    	    	    	  XCL,
  	    	    	    	    	    	  XCLd,
  	    	    	    	    	    	  MRSCL,
  	    	    	    	    	    	  MRSCLd)
  	    	  	  	 SELECT  s.ProdId,
  	    	    	    	  	  	 s.Size,
  	    	    	    	  	  	 s.CL,
  	    	    	    	  	  	 CASE WHEN @SubgroupType = 0 THEN SQRT(s.CL*ABS((1-s.CL))/s.Size) ELSE s.CL END, 
  	    	    	    	  	  	 s.PBar,
  	    	    	    	  	  	 SQRT(s.PBar*(1-s.PBar)/s.Size)
  	    	  	  	 FROM ( SELECT  	  s.ProdId,
  	    	    	    	    	    	  	  	 s.Size,
  	    	    	    	    	    	  	  	 CL  	  = AVG(CAST(Result AS float)),
  	    	    	    	    	    	  	  	 PBar  	  = AVG(PChart)
  	    	    	    	  	  	 FROM #Subgroups s
  	    	    	    	  	  	 GROUP BY  	  ProdId,
  	    	    	    	    	    	    	  	  	 s.Size) s
 	  	 --  	    	    	  LEFT JOIN SPC_Constants c  	  WITH (NOLOCK)
 	  	 --  	    	    	    	    	    	    	    	    	    	  ON c.Subgroup_Size = 2
  	    	  	 END
  	    	   ELSE
  	    	  	 BEGIN
  	    	  	   	 INSERT @Limits (ProdId,
  	    	    	    	    	    	  Size,
  	    	    	    	    	    	  XCL,
  	    	    	    	    	    	  XCLd,
  	    	    	    	    	    	  MRSCL,
  	    	    	    	    	    	  MRSCLd)
  	    	  	  	 SELECT  s.ProdId,
  	    	    	    	  	  	 s.Size,
  	    	    	    	  	  	 NULL, --s.CL,
  	    	    	    	  	  	 NULL, --CASE WHEN @SubgroupType = 0 THEN SQRT(s.CL*(1-s.CL)/s.Size) ELSE s.CL END, 
  	    	    	    	  	  	 s.PBar,
  	    	    	    	  	  	 SQRT(s.PBar*(1-s.PBar)/s.Size)
  	    	  	  	 FROM ( SELECT  	  s.ProdId,
  	    	    	    	    	    	  	  	 s.Size,
  	    	    	    	    	    	  	  	 --CL  	  = AVG(CAST(Result AS float)),
  	    	    	    	    	    	  	  	 PBar  	  = AVG(PChart)
  	    	    	    	  	  	 FROM #Subgroups s
  	    	    	    	  	  	 GROUP BY  	  ProdId,
  	    	    	    	    	    	    	  	  	 s.Size) s
 	  	 --  	    	    	  LEFT JOIN SPC_Constants c  	  WITH (NOLOCK)
 	  	 --  	    	    	    	    	    	    	    	    	    	  ON c.Subgroup_Size = 2
  	    	  	 END 	  	  	 
  	    	  END
 	 -----------------------  UPDATE LIMITS  -----------------------------------
 	 UPDATE s
 	 SET 	 XUCL 	  	 = l.XCL + @SigmaFactor*l.XCLd,
 	  	 XUWL 	  	 = l.XCL + @SigmaFactor*2/3*l.XCLd,
 	  	 XUUL 	  	 = l.XCL + @SigmaFactor*1/3*l.XCLd,
 	  	 XCL 	  	  	 = l.XCL,
 	  	 XLUL 	  	 = l.XCL - @SigmaFactor*1/3*l.XCLd,
 	  	 XLWL 	  	 = l.XCL - @SigmaFactor*2/3*l.XCLd,
 	  	 XLCL 	  	 = l.XCL - @SigmaFactor*l.XCLd,
 	  	 MRSUCL 	  	 = l.MRSCL + @SigmaFactor*l.MRSCLd,
 	  	 MRSUWL 	  	 = l.MRSCL + @SigmaFactor*2/3*l.MRSCLd,
 	  	 MRSUUL 	  	 = l.MRSCL + @SigmaFactor*1/3*l.MRSCLd,
 	  	 MRSCL 	  	 = l.MRSCL,
 	  	 MRSLUL 	  	 = CASE 	 WHEN l.MRSCL - @SigmaFactor*l.MRSCLd > 0 THEN
 	  	  	  	  	  	  	  	  l.MRSCL - @SigmaFactor*1/3*l.MRSCLd
 	  	  	  	  	  	  	 ELSE 0
 	  	  	  	  	  	  	 END,
 	  	 MRSLWL 	  	 = CASE 	 WHEN l.MRSCL - @SigmaFactor*l.MRSCLd > 0 THEN
 	  	  	  	  	  	  	  	  l.MRSCL - @SigmaFactor*2/3*l.MRSCLd
 	  	  	  	  	  	  	 ELSE 0
 	  	  	  	  	  	  	 END,
 	  	 MRSLCL 	  	 = CASE 	 WHEN l.MRSCL - @SigmaFactor*l.MRSCLd > 0 THEN
 	  	  	  	  	  	  	  	  l.MRSCL - @SigmaFactor*l.MRSCLd
 	  	  	  	  	  	  	 ELSE 0
 	  	  	  	  	  	  	 END
 	 FROM #Subgroups s
 	  	 LEFT JOIN @Limits l ON 	 s.ProdId = l.ProdId
 	  	  	  	  	  	  	  	 AND s.Size = l.Size
 	 END
/******************************************************************************
** 	  	  	  	  	  	 DATA POINT TEXT 	  	  	  	  	  	  	  	  	  	  **
******************************************************************************/
IF (@SubgroupType = 0 OR @SPCVarTypeId IS NOT NULL OR @SubGroupSize<1)
BEGIN
--Set the event Ids
Update s
SET s.EventId = t.EventId
FROM #Subgroups s JOIN #Tests t ON s.TestId= t.TestId
Update s
SET DataPointText = dbo.fnTranslate(@LangId,30245,'Event Number') + '=' +  e.Event_Num
FROM #Subgroups s JOIN dbo.Events e ON s.EventId = e.Event_Id
IF @ETId = 14 -- UserDefined Event
BEGIN
Update s
SET DataPointText = dbo.fnTranslate(@LangId,30245,'Event Number') + '=' +  coalesce(e.Friendly_Desc, e.UDE_Desc)
FROM #Subgroups s JOIN dbo.User_Defined_Events e ON s.EventId = e.UDE_Id
END
END
ELSE
BEGIN
UPDATE #Subgroups
SET DataPointText = 	 dbo.fnTranslate(@LangId,135073, 'Subgroup')+ '=' +ltrim(rtrim(convert(nvarchar(25), TimeStamp, 120)))
 	  	  	  	  	 + char(13)
END
 	  	  	  	 -- 	 + 'Value=' + ltrim(rtrim(convert(nvarchar(25), Result)))
 	  	  	  	 -- 	 + char(13)
/******************************************************************************
** 	  	  	  	  	  	  	  	 ALARMS 	  	  	  	  	  	  	  	  	  	  **
******************************************************************************/
---------------------------  FIXED LIMITS  ------------------------------------
IF 	 @CLType = 0
 	 AND ( 	 @SubgroupType = 0
 	  	  	 OR (@SubgroupType = 1
 	  	  	  	 AND @SubgroupSize = 1))
 	 BEGIN
 	 -- Get alarm(s) details for pop-up box
 	 INSERT @Alarms (SubgroupId,
 	  	  	  	  	 AlarmText)
 	 SELECT 	 s.SubgroupId,
 	  	  	 a.Alarm_Desc
 	 FROM #Subgroups s
 	  	 JOIN dbo.Alarms a 	 WITH (NOLOCK)
 	  	  	  	  	  	  	 ON 	 a.Start_Time <= s.TimeStamp
 	  	  	  	  	  	  	  	 AND ( 	 a.End_Time > s.TimeStamp
 	  	  	  	  	  	  	  	  	  	 OR a.End_Time IS NULL)
 	  	  	 JOIN dbo.Alarm_Template_Var_Data atd 	 WITH (NOLOCK)
 	  	  	  	  	  	  	  	  	  	  	  	  	 ON a.ATD_Id = atd.ATD_Id
 	 WHERE 	 a.Alarm_Type_Id IN (2,4) 	 -- SPC, SPC Group
 	  	  	 AND atd.Var_Id = @VariableId
 	 ORDER BY 	 s.SubgroupId,
 	  	  	  	 a.Alarm_Id
 	 -- Consolidate multiple alarm details into a single string
 	 UPDATE a1
 	 SET AlarmOrder = a1.AlarmId - amin.MinAlarmId + 1
 	 FROM @Alarms a1
 	  	 LEFT JOIN ( 	 SELECT 	 SubgroupId,
 	  	  	  	  	  	  	 MIN(AlarmId) AS MinAlarmId
 	  	  	  	  	 FROM @Alarms
 	  	  	  	  	 GROUP BY SubgroupId) amin ON a1.SubgroupId = amin.SubgroupId
 	 SET @AlarmOrder = 1
 	 WHILE @@ROWCOUNT > 0
 	  	 BEGIN
 	  	 SELECT @AlarmOrder = @AlarmOrder + 1
 	  	 UPDATE a1
 	  	 SET AlarmText = a1.AlarmText + char(13) + a2.AlarmText
 	  	 FROM @Alarms a1
 	  	  	 JOIN @Alarms a2 ON a1.SubgroupId = a2.SubgroupId
 	  	  	  	  	  	  	  	 AND a2.AlarmOrder = @AlarmOrder
 	  	 WHERE a1.AlarmOrder = 1
 	  	 END
 	 -- Update alarm flag for data point colour coding
 	 UPDATE s
 	 SET 	 Alarm 	  	  	 = 1,
 	  	 DataPointText 	 = DataPointText + char(13) + 'Alarms:' + char(13) + AlarmText 
 	 FROM #Subgroups s
 	  	 JOIN @Alarms a ON 	 s.SubgroupId = a.SubgroupId
 	  	  	  	  	  	  	 AND a.AlarmOrder = 1
 	 END
--------------------------  CALCULATED LIMITS  --------------------------------
ELSE -- IF @CLType = 1
 	 BEGIN
 	 UPDATE #Subgroups
 	 SET 	 Alarm = 1
 	 WHERE SubgroupId IN ( 	 SELECT s.SubgroupId
 	  	  	  	  	  	  	 FROM #Subgroups s
 	  	  	  	  	  	  	 WHERE 	 ( 	 CONVERT(float,s.Result) > s.XUCL
 	  	  	  	  	  	  	  	  	  	 OR CONVERT(float,s.Result) < s.XLCL )
 	  	  	  	  	  	  	  	  	 OR (@SpecParm = 2
 	  	  	  	  	  	  	  	  	  	 AND 	 ( 	 CONVERT(float,s.Result) = s.XUCL
 	  	  	  	  	  	  	  	  	  	  	  	 OR CONVERT(float,s.Result) = s.XLCL)))
 	 END
/******************************************************************************
** 	  	  	  	  	  	  	  	 STATISTICS 	  	  	  	  	  	  	  	  	  **
******************************************************************************/
-- Get product grouping and basic statistics
INSERT @Statistics (ProdId,
 	  	  	  	  	 LSL,
 	  	  	  	  	 USL,
 	  	  	  	  	 Target,
 	  	  	  	  	 Mean,
 	  	  	  	  	 Minimum,
 	  	  	  	  	 Maximum,
 	  	  	  	  	 NumberOfPoints,
 	  	  	  	  	 EstimatedSigma)
SELECT 	 ProdId,
 	  	 XLSL,
 	  	 XUSL,
 	  	 ISNULL(Target, (XUSL+XLSL)/2),
 	  	 AVG(CONVERT(float,Result)),
 	  	 MIN(CONVERT(float,Result)),
 	  	 MAX(CONVERT(float,Result)),
 	  	 COUNT(CONVERT(float,Result)),
 	  	 CASE WHEN 	 @SubgroupSize = 1 THEN
 	  	  	  	  	 AVG(MR)/dbo.fnCmn_SampleSizeLookup(2, 'd2')
 	  	  	  WHEN 	 @SubgroupSize >= 2
 	  	  	  	  	 OR @SubgroupSize <= 25 THEN
 	  	  	  	  	 AVG(R)/dbo.fnCmn_SampleSizeLookup(@SubgroupSize, 'd2')
 	  	  	  ELSE
 	  	  	  	  	 AVG(S)/dbo.fnCmn_SampleSizeLookup(@SubgroupSize, 'c4')
 	  	  	  END
FROM #Subgroups
GROUP BY 	 ProdId,
 	  	  	 XLSL,
 	  	  	 XUSL,
 	  	  	 Target
ORDER BY MAX(TimeStamp) DESC
-- Calculate process statistics -- MKW 2009-06-22
IF @SPCVarTypeId IS NOT NULL
 	 BEGIN
 	 UPDATE s
 	 SET 	 ProcessMean 	  	 = t.Mean,
 	  	 ProcessSigma 	 = t.Sigma,
 	  	 ProcessMinimum 	 = t.Minimum,
 	  	 ProcessMaximum 	 = t.Maximum
 	 FROM @Statistics s
 	  	 JOIN ( 	 SELECT 	 t2.ProdId,
 	  	  	  	  	  	 AVG(convert(float, t.Result)) AS Mean,
 	  	  	  	  	  	 STDEV(convert(float, t.Result)) AS Sigma,
 	  	  	  	  	  	 MIN(convert(float, t.Result)) AS Minimum,
 	  	  	  	  	  	 MAX(convert(float, t.Result)) AS Maximum
 	  	  	  	 FROM dbo.Tests t WITH (NOLOCK)
 	  	  	  	  	 JOIN @Individuals i ON t.Var_Id = i.VarId
 	  	  	  	  	 JOIN #Tests t2 ON t.Result_On = t2.TimeStamp
 	  	  	  	 GROUP BY t2.ProdId) AS t ON s.ProdId = t.ProdId
 	 END
ELSE
 	 BEGIN
 	 UPDATE s
 	 SET 	 ProcessMean 	  	 = t.Mean,
 	  	 ProcessSigma 	 = t.Sigma,
 	  	 ProcessMinimum 	 = t.Minimum,
 	  	 ProcessMaximum 	 = t.Maximum
 	 FROM @Statistics s
 	  	 JOIN ( 	 SELECT 	 ProdId,
 	  	  	  	  	  	 AVG(CONVERT(float,Result)) AS Mean,
 	  	  	  	  	  	 STDEV(CONVERT(float,Result)) AS Sigma,
 	  	  	  	  	  	 MIN(CONVERT(float,Result)) AS Minimum,
 	  	  	  	  	  	 MAX(CONVERT(float,Result)) AS Maximum
 	  	  	  	 FROM #Tests
  	    	    	    	 WHERE @DType_Id IN (1, 2) --MK
 	  	  	  	 GROUP BY ProdId ) t ON s.ProdId = t.ProdId
 	 END
-- Calculate Histogram Limits -- MKW 2009-06-22
UPDATE s
SET 	 UCL 	 = s.Mean + 3*s.EstimatedSigma,
 	 LCL 	 = s.Mean - 3*s.EstimatedSigma
FROM @Statistics s
UPDATE s
SET 	 Zlsl 	 = CASE  	 WHEN s.ProcessSigma <> 0 THEN
 	  	  	  	  	  	 (s.ProcessMean - s.LSL)/s.ProcessSigma
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Zusl 	 = CASE  	 WHEN s.ProcessSigma <> 0 THEN
 	  	  	  	  	  	 (s.USL - s.ProcessMean)/s.ProcessSigma
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Zt 	  	 = CASE  	 WHEN s.ProcessSigma <> 0 THEN
 	  	  	  	  	  	 (s.Mean - s.Target)/s.ProcessSigma
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Cr 	  	 = CASE  	 WHEN s.USL <> s.LSL THEN
 	  	  	  	  	  	 (6*s.EstimatedSigma)/(s.USL - s.LSL)
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Cp 	  	 = CASE  	 WHEN s.EstimatedSigma <> 0 THEN
 	  	  	  	  	  	 (s.USL - s.LSL)/(6*s.EstimatedSigma) -- 1/Cr
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Cpl 	  	 = CASE  	 WHEN s.EstimatedSigma <> 0 THEN
 	  	  	  	  	  	 (s.Mean - s.LSL)/(3*s.EstimatedSigma)
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Cpu 	  	 = CASE  	 WHEN s.EstimatedSigma <> 0 THEN
 	  	  	  	  	  	 (s.USL - s.Mean)/(3*s.EstimatedSigma)
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Cpm 	  	 = CASE  	 WHEN 	 s.EstimatedSigma <> 0
 	  	  	  	  	  	  	 AND (s.Mean <> s.Target) THEN
 	  	  	  	  	  	 (s.USL - s.LSL)/(6*SQRT(POWER(s.EstimatedSigma,2)+POWER(s.Mean-s.Target,2)))
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Pp 	  	 = CASE  	 WHEN s.ProcessSigma <> 0 THEN (s.USL - s.LSL)/(6*s.ProcessSigma)
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Ppl 	  	 = CASE  	 WHEN s.ProcessSigma <> 0 THEN (s.ProcessMean - s.LSL)/(3*s.ProcessSigma)
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END, 
 	 Ppu 	  	 = CASE  	 WHEN s.ProcessSigma <> 0 THEN (s.USL - s.ProcessMean)/(3*s.ProcessSigma)
 	  	  	  	  	 ELSE NULL
 	  	  	  	  	 END
FROM @Statistics s
UPDATE s
SET 	 Cpk 	 = CASE 	 WHEN Cpl <= Cpu THEN Cpl
 	  	  	  	 WHEN Cpl is NULL THEN Cpu
 	  	  	  	 WHEN Cpu is NULL THEN Cpl
 	  	  	  	 ELSE Cpu
 	  	  	  	 END,
 	 Ppk 	 = CASE 	 WHEN Ppl <= Ppu THEN Ppl
 	  	  	  	 WHEN Ppl is NULL THEN Ppu
 	  	  	  	 WHEN Ppu is NULL THEN Ppl
 	  	  	  	 ELSE Ppu
 	  	  	  	 END
FROM @Statistics s
/*****************************************************************************
* 	  	  	  	  	  	  	 HISTOGRAM
*****************************************************************************/
-- I think this could be done in the report itself by grouping the raw dataset
/*****************************************************************************
* 	  	  	  	  	  	  	 RETURN RESULTS
*****************************************************************************/
--**********************************************
-- RETURN Header Information
--**********************************************
-- Line1: Report Name
-- Line2: Criteria
-- Line3: Generate Time
-- Line4 - n: Column Names
DECLARE @UnitName nVarChar(100)
DECLARE @VariableName nVarChar(100)
DECLARE @Precision int
Create Table #Prompts (
  PromptId int identity(1,1),
  PromptName nvarchar(20),
  PromptValue nvarchar(1000),
  PromptValue_Parameter SQL_Variant,
  PromptValue_Parameter2 SQL_Variant,
  PromptValue_Parameter3 SQL_Variant,
 	 PromptValue_Parameter4 SQL_Variant
)
 SELECT @UnitName=PU_Desc FROM Prod_Units WHERE Pu_ID=@PUID
 SELECT @VariableName=Var_Desc,@Precision=coalesce(var_precision, 0) FROM Variables WHERE Var_Id=@VariableId
If @NumberOfPoints = 0 or @NumberOfPoints Is Null
  Insert into #Prompts (PromptName, PromptValue, PromptValue_Parameter, PromptValue_Parameter2, PromptValue_Parameter3,PromptValue_Parameter4)
    Values('Criteria', dbo.fnTranslate(@LangId, 35312, 'From [{1}] To [{2}]') + 'Of [{3}]', '', dbo.fnServer_CmnConvertFromDBTime(@StartTime,@InTimeZone),dbo.fnServer_CmnConvertFromDBTime(@EndTime,@InTimeZone),@VariableName)
Else
If @Direction=1
  Insert into #Prompts (PromptName, PromptValue, PromptValue_Parameter, PromptValue_Parameter2, PromptValue_Parameter3,PromptValue_Parameter4)
    Values('Criteria', dbo.fnTranslate(@LangId, 35313, 'For [{1}] From [{2}]')+ 'Of [{3}]', '', @NumberOfPoints, dbo.fnServer_CmnConvertFromDBTime(@EndTime,@InTimeZone),@VariableName)
Else
 	 Insert into #Prompts (PromptName, PromptValue, PromptValue_Parameter, PromptValue_Parameter2, PromptValue_Parameter3,PromptValue_Parameter4)
    Values('Criteria', dbo.fnTranslate(@LangId, 35313, 'For [{1}] From [{2}]')+ 'Of [{3}]', '', @NumberOfPoints, dbo.fnServer_CmnConvertFromDBTime(@StartTime,@InTimeZone),@VariableName)
Insert into #Prompts (PromptName, PromptValue, PromptValue_Parameter) Values('GenerateTime', dbo.fnTranslate(@LangId, 34521, 'Created: [{0}]'), dbo.fnServer_CmnGetDate(getutcdate()))
Insert into #Prompts (PromptName, PromptValue) Values('CriteriaSummary', dbo.fnTranslate(@LangId, 34868, 'Criteria Summary'))
Insert into #Prompts (PromptName, PromptValue) Values('StatisticsSummary', dbo.fnTranslate(@LangId, 34870, 'Statistics Summary'))
Insert into #Prompts (PromptName, PromptValue) Values('ProductCapability', dbo.fnTranslate(@LangId, 34873, 'Product Capability'))
Insert into #Prompts (PromptName, PromptValue) Values('ControlChart', dbo.fnTranslate(@LangId, 34876, 'Control Chart'))
Insert into #Prompts (PromptName, PromptValue) Values('Average', dbo.fnTranslate(@LangId, 34031, 'Average'))
Insert into #Prompts (PromptName, PromptValue) Values('Minimum', dbo.fnTranslate(@LangId, 34029, 'Minimum'))
Insert into #Prompts (PromptName, PromptValue) Values('Maximum', dbo.fnTranslate(@LangId, 34030, 'Maximum'))
Insert into #Prompts (PromptName, PromptValue) Values('StandardDeviation', dbo.fnTranslate(@LangId, 34877, 'Standard Deviation'))
Insert into #Prompts (PromptName, PromptValue) Values('NumberOfPoints', dbo.fnTranslate(@LangId, 34878, '#Values'))
Insert Into #Prompts (PromptName, PromptValue) Values('ProductCode', dbo.fnTranslate(@LangId, 34973, 'Product Code'))
Insert Into #Prompts (PromptName, PromptValue) Values('ProductDescription', dbo.fnTranslate(@LangId, 34974, 'Product Description'))
Insert into #Prompts (PromptName, PromptValue) Values ('Limit', dbo.fnTranslate(@LangId, 34879, 'Limit'))
Insert into #Prompts (PromptName, PromptValue) Values ('EndLimit', dbo.fnTranslate(@LangId, 34880, 'Last Limit'))
Insert into #Prompts (PromptName, PromptValue) Values ('CurrentLimit', dbo.fnTranslate(@LangId, 34881, 'Current Limit'))
Insert into #Prompts (PromptName, PromptValue) Values ('TheoreticalLimit', dbo.fnTranslate(@LangId, 34882, 'Theoretical Limit'))
Insert into #Prompts (PromptName, PromptValue) Values ('Deviation', dbo.fnTranslate(@LangId, 34883, 'Deviation'))
Insert into #Prompts (PromptName, PromptValue) Values ('SigmaDeviation', dbo.fnTranslate(@LangId, 34884, 'Percent Sigma'))
Insert into #Prompts (PromptName, PromptValue) Values ('VariableId', Convert(nvarchar(20), @VariableId))
Insert into #Prompts (PromptName, PromptValue) Values ('Precision', Convert(nvarchar(20), 6))
Insert into #Prompts (PromptName, PromptValue) Values ('Product',dbo.fnTranslate(@LangId, 34863, 'Product'))
Insert into #Prompts (PromptName, PromptValue) Values ('LSL', dbo.fnTranslate(@LangId, 35330, 'LSL'))
Insert into #Prompts (PromptName, PromptValue) Values ('USL', dbo.fnTranslate(@LangId, 35329, 'USL'))
Insert into #Prompts (PromptName, PromptValue) Values ('Target', dbo.fnTranslate(@LangId, 34669, 'Target'))
Insert into #Prompts (PromptName, PromptValue) Values ('EstimatedSigma', dbo.fnTranslate(@LangId, 35331, 'Estimated Sigma'))
Insert into #Prompts (PromptName, PromptValue) Values ('ProcessMean', dbo.fnTranslate(@LangId, 35332, 'Process Mean'))
Insert Into #Prompts (PromptName, PromptValue,PromptValue_Parameter) Values ('StartTime', '[{0}]', dbo.fnServer_CmnConvertFromDBTime(@StartTime,@InTimeZone))
Insert Into #Prompts (PromptName, PromptValue, PromptValue_Parameter) Values ('EndTime', '[{0}]', dbo.fnServer_CmnConvertFromDBTime(@EndTime,@InTimeZone))
Insert Into #Prompts (PromptName, PromptValue, PromptValue_Parameter, PromptValue_Parameter2, PromptValue_Parameter3) Values ('NotRunOnBasisProduct', dbo.fnTranslate(@LangId, 35161, 'The selected products were not run on [{0}] from [{1}] to [{2}].'), @UnitName, @StartTime, @EndTime)
Insert Into #Prompts (PromptName, PromptValue) Values ('GoodValue', @GoodValue)
Insert into #Prompts (PromptName, PromptValue) Values ('ProcessCapability', dbo.fnTranslate(@LangId, 34930, 'Process Capability'))
Insert into #Prompts (PromptName, PromptValue) Values ('Statistics', dbo.fnTranslate(@LangId, 35310, 'Statistics'))
Insert into #Prompts (PromptName, PromptValue) Values ('Cr', dbo.fnTranslate(@LangId,236033 , 'Cr'))
Insert into #Prompts (PromptName, PromptValue) Values ('Cp', dbo.fnTranslate(@LangId, 38499, 'Cp'))
Insert into #Prompts (PromptName, PromptValue) Values ('Cpk', dbo.fnTranslate(@LangId, 38440, 'Cpk'))
Insert into #Prompts (PromptName, PromptValue) Values ('Pp', dbo.fnTranslate(@LangId, 38498, 'Pp'))
Insert into #Prompts (PromptName, PromptValue) Values ('Ppk', dbo.fnTranslate(@LangId, 38497, 'Ppk'))
Insert into #Prompts (PromptName, PromptValue) Values ('Cpm', dbo.fnTranslate(@LangId, 35333, 'Cpm'))
Insert into #Prompts (PromptName, PromptValue) Values ('ProcessMaximum', dbo.fnTranslate(@LangId, 35334, 'Process Maximum'))
Insert into #Prompts (PromptName, PromptValue) Values ('ProcessMinimum', dbo.fnTranslate(@LangId, 35335, 'Process Minimum'))
Insert into #Prompts (PromptName, PromptValue) Values ('Zlsl', dbo.fnTranslate(@LangId, 35336, 'Zlsl'))
Insert into #Prompts (PromptName, PromptValue) Values ('Zusl', dbo.fnTranslate(@LangId, 35337, 'Zusl'))
Insert into #Prompts (PromptName, PromptValue) Values ('Zt', dbo.fnTranslate(@LangId, 35338, 'Zt'))
select * From #Prompts
Drop Table #Prompts
--**********************************************
-- RETURN Basic Resultset With High Level Info
--**********************************************
-- Create Simple RETURN Table
Create Table #Information (
  [Id] int identity(1,1),
  [Name] nvarchar(50),
  Value varchar(8000) NULL,
  Value_Parameter SQL_Variant,
  Hyperlink nvarchar(255) NULL
)
------------Ramesh Added the following code--------
DECLARE @ProductsList varchar(8000) 
SELECT @ProductsList = COALESCE(@ProductsList + ', ', '') + prod_Code FROM Products WHERE Prod_Id IN (SELECT ProdId FROM @Products)
DECLARE @POList varchar(8000)
SELECT @POList =COALESCE(@POList + ', ', '') + Process_Order FROM Production_Plan WHERE PP_Id IN (SELECT PPId FROM @Orders)
--**********************************************
-- RETURN Basic Criteria
--**********************************************
Truncate Table #Information
Insert Into #Information ([Name], Value) Values (dbo.fnTranslate(@LangId, 34847, 'Variable'), @VariableName)
Insert Into #Information ([Name], Value) Values (dbo.fnTranslate(@LangId, 34850, 'Unit'), @UnitName)
If @NumberOfPoints > 0 
  Begin
    Insert Into #Information ([Name], Value, Value_Parameter) Values (dbo.fnTranslate(@LangId, 34158, 'Number Of Points'), '[{0}]', @NumberOfPoints)
    If @Direction = 1
      Insert Into #Information ([Name], Value, Value_Parameter) Values (dbo.fnTranslate(@LangId, 34885, 'Backwards From'), '[{0}]', dbo.fnServer_CmnConvertFromDBTime(@EndTime,@InTimeZone))
    Else
      Insert Into #Information ([Name], Value, Value_Parameter) Values (dbo.fnTranslate(@LangId, 34886, 'Forward From'), '[{0}]', dbo.fnServer_CmnConvertFromDBTime(@StartTime,@InTimeZone))
  End
Else
  Begin
    Insert Into #Information ([Name], Value, Value_Parameter) Values(dbo.fnTranslate(@LangId, 34011, 'Start Time'), '[{0}]', dbo.fnServer_CmnConvertFromDBTime(@StartTime,@InTimeZone))
    Insert Into #Information ([Name], Value, Value_Parameter) Values(dbo.fnTranslate(@LangId, 34012, 'End Time'), '[{0}]', dbo.fnServer_CmnConvertFromDBTime(@EndTime,@InTimeZone))
  End
Insert Into #Information ([Name],Value) Values (dbo.fnTranslate(@LangId,30831,'Product(s)'),@ProductsList)
Insert Into #Information ([Name],Value) Values (dbo.fnTranslate(@LangId,35314,'Crew(s)') ,@CrewList)
Insert Into #Information ([Name],Value) Values (dbo.fnTranslate(@LangId,35315,'Shift(s)'),@ShiftList)
Insert Into #Information ([Name],Value) Values (dbo.fnTranslate(@LangId,36415,'Process Order(s)'),@OrderList)
Insert Into #Information ([Name],Value) Values (dbo.fnTranslate(@LangId,30858,'Event(s)'),@EventNum)
If @SubgroupType=0 
 	 Begin 
 	  	 Insert Into #Information([Name],Value) Values(dbo.fnTranslate(@LangId,35296,'SubgroupType'),dbo.fnTranslate(@LangId,34847, 'Variable'))
 	 End
Else
 	 Begin
 	  	 Insert Into #Information([Name],Value) Values(dbo.fnTranslate(@LangId,35296,'SubgroupType'),dbo.fnTranslate(@LangId,35321, 'Time-Series'))
 	 End
If @CLType=0 
 	 Begin
 	  	 Insert Into #Information([Name],Value) Values(dbo.fnTranslate(@LangId,35318,'Control Limit Type'),dbo.fnTranslate(@LangId,35322,'Defined Specification Limits'))
 	 End
Else
 	 Begin
 	  	 Insert Into #Information([Name],Value) Values(dbo.fnTranslate(@LangId,35318,'Control Limit Type'),dbo.fnTranslate(@LangId,35323,'Calculated Limits'))
 	 End
Insert Into #Information ([Name],Value) Values(dbo.fnTranslate(@LangId,35297,'Subgroup Size'),@SubgroupSize)
Insert Into #Information ([Name],Value) Values(dbo.fnTranslate(@LangId,35319,'Good Value'),@GoodValue)
Select * From #Information Order By Id
------------End of Ramesh --------------------------
----------------------------  STATISTICS  ------------------------------------
SELECT 	 RunId,
 	  	 s.ProdId,
 	  	 p.Prod_Desc,
 	  	 LSL,
 	  	 USL,
 	  	 Target,
 	  	 Mean AS Average,
 	  	 Minimum,
 	  	 Maximum,
 	  	 EstimatedSigma,
 	  	 ProcessMean,
 	  	 ProcessMinimum,
 	  	 ProcessMaximum,
 	  	 ProcessSigma AS Sigma,
 	  	 LCL,
 	  	 UCL,
 	  	 NumberofPoints,
 	  	 Cr,
 	  	 Cp,
 	  	 Cpk,
 	  	 Cpm,
 	  	 Pp,
 	  	 Ppk,
 	  	 Zlsl,
 	  	 Zusl,
 	  	 Zt
FROM @Statistics s
JOIN Products p ON s.ProdId=p.Prod_Id
-----------------------------  CHART DATA  ------------------------------------
SELECT 	 SubgroupId,
 	  	 dbo.fnServer_CmnConvertFromDBTime(Timestamp,@InTimeZone) [Timestamp],
 	  	 Result,
 	  	 R,
 	  	 S,
 	  	 MR,
  	    	  UChart,
  	    	  PChart, 	 
 	  	 XUSL,
 	  	 XUCL,
 	  	 XUWL,
 	  	 XUUL,
 	  	 XCL,
 	  	 XLUL,
 	  	 XLWL,
 	  	 XLCL,
 	  	 XLSL,
 	  	 MRSUSL,
 	  	 MRSUCL,
 	  	 MRSUWL,
 	  	 MRSUUL,
 	  	 MRSCL,
 	  	 MRSLUL,
 	  	 MRSLWL,
 	  	 MRSLCL,
 	  	 MRSLSL,
 	  	 Alarm,
 	  	 DataPointText
FROM #Subgroups
WHERE ProdId > 0
ORDER BY Timestamp
-------------------------------  RAW DATA  ------------------------------------
SELECT Top 1 @BasisProduct =  ProdId FROM #Tests order By timestamp desc
SELECT 	 t.XId,
 	  	 t.SubgroupId,
 	  	 dbo.fnServer_CmnConvertFromDBTime(t.TimeStamp,@InTimeZone) [TimeStamp],
  	    	  CASE @DType_Id WHEN 1 THEN CONVERT(float, t.Result)
  	    	  	  	 WHEN 2 THEN CONVERT(float, t.Result)
  	    	  	  	 ELSE NULL END AS Value,
  	    	  t.Result AS RawValue,
 	  	 p.Prod_Code,
 	  	 IsBasisProduct=
 	  	 Case 
 	  	 When t.ProdId =  @BasisProduct Then 1
 	  	 Else 0
 	 End
FROM #Tests t
 	 JOIN Products p ON t.ProdId = p.Prod_Id
Order By t.TimeStamp
/*****************************************************************************
* 	  	  	  	  	  	  	 CLEANUP
*****************************************************************************/
lblend:
DROP TABLE #Information
DROP TABLE #Tests
DROP TABLE #SubgroupIndex
DROP TABLE #Subgroups
